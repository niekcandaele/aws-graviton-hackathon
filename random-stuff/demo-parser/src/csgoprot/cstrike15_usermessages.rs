// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cstrike15_usermessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VGUIMenu {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    show: ::std::option::Option<bool>,
    pub subkeys: ::protobuf::RepeatedField<CCSUsrMsg_VGUIMenu_Subkey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VGUIMenu {
    fn default() -> &'a CCSUsrMsg_VGUIMenu {
        <CCSUsrMsg_VGUIMenu as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VGUIMenu {
    pub fn new() -> CCSUsrMsg_VGUIMenu {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show = 2;


    pub fn get_show(&self) -> bool {
        self.show.unwrap_or(false)
    }
    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    // repeated .CCSUsrMsg_VGUIMenu.Subkey subkeys = 3;


    pub fn get_subkeys(&self) -> &[CCSUsrMsg_VGUIMenu_Subkey] {
        &self.subkeys
    }
    pub fn clear_subkeys(&mut self) {
        self.subkeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_subkeys(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_VGUIMenu_Subkey>) {
        self.subkeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subkeys(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_VGUIMenu_Subkey> {
        &mut self.subkeys
    }

    // Take field
    pub fn take_subkeys(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_VGUIMenu_Subkey> {
        ::std::mem::replace(&mut self.subkeys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_VGUIMenu {
    fn is_initialized(&self) -> bool {
        for v in &self.subkeys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subkeys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.show {
            my_size += 2;
        }
        for value in &self.subkeys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.show {
            os.write_bool(2, v)?;
        }
        for v in &self.subkeys {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VGUIMenu {
        CCSUsrMsg_VGUIMenu::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CCSUsrMsg_VGUIMenu| { &m.name },
                |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show",
                |m: &CCSUsrMsg_VGUIMenu| { &m.show },
                |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.show },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_VGUIMenu_Subkey>>(
                "subkeys",
                |m: &CCSUsrMsg_VGUIMenu| { &m.subkeys },
                |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.subkeys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_VGUIMenu>(
                "CCSUsrMsg_VGUIMenu",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_VGUIMenu {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_VGUIMenu> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_VGUIMenu::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VGUIMenu {
    fn clear(&mut self) {
        self.name.clear();
        self.show = ::std::option::Option::None;
        self.subkeys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VGUIMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VGUIMenu {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VGUIMenu_Subkey {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    str: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VGUIMenu_Subkey {
    fn default() -> &'a CCSUsrMsg_VGUIMenu_Subkey {
        <CCSUsrMsg_VGUIMenu_Subkey as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VGUIMenu_Subkey {
    pub fn new() -> CCSUsrMsg_VGUIMenu_Subkey {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string str = 2;


    pub fn get_str(&self) -> &str {
        match self.str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_str(&mut self) {
        self.str.clear();
    }

    pub fn has_str(&self) -> bool {
        self.str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_str(&mut self, v: ::std::string::String) {
        self.str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_str(&mut self) -> &mut ::std::string::String {
        if self.str.is_none() {
            self.str.set_default();
        }
        self.str.as_mut().unwrap()
    }

    // Take field
    pub fn take_str(&mut self) -> ::std::string::String {
        self.str.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_VGUIMenu_Subkey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.str.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.str.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VGUIMenu_Subkey {
        CCSUsrMsg_VGUIMenu_Subkey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CCSUsrMsg_VGUIMenu_Subkey| { &m.name },
                |m: &mut CCSUsrMsg_VGUIMenu_Subkey| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "str",
                |m: &CCSUsrMsg_VGUIMenu_Subkey| { &m.str },
                |m: &mut CCSUsrMsg_VGUIMenu_Subkey| { &mut m.str },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_VGUIMenu_Subkey>(
                "CCSUsrMsg_VGUIMenu.Subkey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_VGUIMenu_Subkey {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_VGUIMenu_Subkey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_VGUIMenu_Subkey::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VGUIMenu_Subkey {
    fn clear(&mut self) {
        self.name.clear();
        self.str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VGUIMenu_Subkey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VGUIMenu_Subkey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Geiger {
    // message fields
    range: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Geiger {
    fn default() -> &'a CCSUsrMsg_Geiger {
        <CCSUsrMsg_Geiger as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Geiger {
    pub fn new() -> CCSUsrMsg_Geiger {
        ::std::default::Default::default()
    }

    // optional int32 range = 1;


    pub fn get_range(&self) -> i32 {
        self.range.unwrap_or(0)
    }
    pub fn clear_range(&mut self) {
        self.range = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: i32) {
        self.range = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Geiger {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.range = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.range {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.range {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Geiger {
        CCSUsrMsg_Geiger::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "range",
                |m: &CCSUsrMsg_Geiger| { &m.range },
                |m: &mut CCSUsrMsg_Geiger| { &mut m.range },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_Geiger>(
                "CCSUsrMsg_Geiger",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_Geiger {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_Geiger> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_Geiger::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Geiger {
    fn clear(&mut self) {
        self.range = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Geiger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Geiger {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Train {
    // message fields
    train: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Train {
    fn default() -> &'a CCSUsrMsg_Train {
        <CCSUsrMsg_Train as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Train {
    pub fn new() -> CCSUsrMsg_Train {
        ::std::default::Default::default()
    }

    // optional int32 train = 1;


    pub fn get_train(&self) -> i32 {
        self.train.unwrap_or(0)
    }
    pub fn clear_train(&mut self) {
        self.train = ::std::option::Option::None;
    }

    pub fn has_train(&self) -> bool {
        self.train.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train(&mut self, v: i32) {
        self.train = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Train {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.train = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.train {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.train {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Train {
        CCSUsrMsg_Train::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "train",
                |m: &CCSUsrMsg_Train| { &m.train },
                |m: &mut CCSUsrMsg_Train| { &mut m.train },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_Train>(
                "CCSUsrMsg_Train",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_Train {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_Train> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_Train::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Train {
    fn clear(&mut self) {
        self.train = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Train {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Train {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_HudText {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HudText {
    fn default() -> &'a CCSUsrMsg_HudText {
        <CCSUsrMsg_HudText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HudText {
    pub fn new() -> CCSUsrMsg_HudText {
        ::std::default::Default::default()
    }

    // optional string text = 1;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_HudText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_HudText {
        CCSUsrMsg_HudText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &CCSUsrMsg_HudText| { &m.text },
                |m: &mut CCSUsrMsg_HudText| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_HudText>(
                "CCSUsrMsg_HudText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_HudText {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_HudText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_HudText::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_HudText {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_HudText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HudText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SayText {
    // message fields
    ent_idx: ::std::option::Option<i32>,
    text: ::protobuf::SingularField<::std::string::String>,
    chat: ::std::option::Option<bool>,
    textallchat: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SayText {
    fn default() -> &'a CCSUsrMsg_SayText {
        <CCSUsrMsg_SayText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SayText {
    pub fn new() -> CCSUsrMsg_SayText {
        ::std::default::Default::default()
    }

    // optional int32 ent_idx = 1;


    pub fn get_ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }
    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional string text = 2;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool chat = 3;


    pub fn get_chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }
    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    // optional bool textallchat = 4;


    pub fn get_textallchat(&self) -> bool {
        self.textallchat.unwrap_or(false)
    }
    pub fn clear_textallchat(&mut self) {
        self.textallchat = ::std::option::Option::None;
    }

    pub fn has_textallchat(&self) -> bool {
        self.textallchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textallchat(&mut self, v: bool) {
        self.textallchat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SayText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ent_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.textallchat = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat {
            my_size += 2;
        }
        if let Some(v) = self.textallchat {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ent_idx {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.textallchat {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SayText {
        CCSUsrMsg_SayText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ent_idx",
                |m: &CCSUsrMsg_SayText| { &m.ent_idx },
                |m: &mut CCSUsrMsg_SayText| { &mut m.ent_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &CCSUsrMsg_SayText| { &m.text },
                |m: &mut CCSUsrMsg_SayText| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chat",
                |m: &CCSUsrMsg_SayText| { &m.chat },
                |m: &mut CCSUsrMsg_SayText| { &mut m.chat },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "textallchat",
                |m: &CCSUsrMsg_SayText| { &m.textallchat },
                |m: &mut CCSUsrMsg_SayText| { &mut m.textallchat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SayText>(
                "CCSUsrMsg_SayText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SayText {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SayText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SayText::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SayText {
    fn clear(&mut self) {
        self.ent_idx = ::std::option::Option::None;
        self.text.clear();
        self.chat = ::std::option::Option::None;
        self.textallchat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SayText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SayText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SayText2 {
    // message fields
    ent_idx: ::std::option::Option<i32>,
    chat: ::std::option::Option<bool>,
    msg_name: ::protobuf::SingularField<::std::string::String>,
    pub params: ::protobuf::RepeatedField<::std::string::String>,
    textallchat: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SayText2 {
    fn default() -> &'a CCSUsrMsg_SayText2 {
        <CCSUsrMsg_SayText2 as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SayText2 {
    pub fn new() -> CCSUsrMsg_SayText2 {
        ::std::default::Default::default()
    }

    // optional int32 ent_idx = 1;


    pub fn get_ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }
    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional bool chat = 2;


    pub fn get_chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }
    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    // optional string msg_name = 3;


    pub fn get_msg_name(&self) -> &str {
        match self.msg_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_msg_name(&mut self) {
        self.msg_name.clear();
    }

    pub fn has_msg_name(&self) -> bool {
        self.msg_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_name(&mut self, v: ::std::string::String) {
        self.msg_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_name(&mut self) -> &mut ::std::string::String {
        if self.msg_name.is_none() {
            self.msg_name.set_default();
        }
        self.msg_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_name(&mut self) -> ::std::string::String {
        self.msg_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string params = 4;


    pub fn get_params(&self) -> &[::std::string::String] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }

    // optional bool textallchat = 5;


    pub fn get_textallchat(&self) -> bool {
        self.textallchat.unwrap_or(false)
    }
    pub fn clear_textallchat(&mut self) {
        self.textallchat = ::std::option::Option::None;
    }

    pub fn has_textallchat(&self) -> bool {
        self.textallchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textallchat(&mut self, v: bool) {
        self.textallchat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SayText2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ent_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.msg_name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.params)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.textallchat = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat {
            my_size += 2;
        }
        if let Some(ref v) = self.msg_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.textallchat {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ent_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.msg_name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.params {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.textallchat {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SayText2 {
        CCSUsrMsg_SayText2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ent_idx",
                |m: &CCSUsrMsg_SayText2| { &m.ent_idx },
                |m: &mut CCSUsrMsg_SayText2| { &mut m.ent_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chat",
                |m: &CCSUsrMsg_SayText2| { &m.chat },
                |m: &mut CCSUsrMsg_SayText2| { &mut m.chat },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "msg_name",
                |m: &CCSUsrMsg_SayText2| { &m.msg_name },
                |m: &mut CCSUsrMsg_SayText2| { &mut m.msg_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "params",
                |m: &CCSUsrMsg_SayText2| { &m.params },
                |m: &mut CCSUsrMsg_SayText2| { &mut m.params },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "textallchat",
                |m: &CCSUsrMsg_SayText2| { &m.textallchat },
                |m: &mut CCSUsrMsg_SayText2| { &mut m.textallchat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SayText2>(
                "CCSUsrMsg_SayText2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SayText2 {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SayText2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SayText2::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SayText2 {
    fn clear(&mut self) {
        self.ent_idx = ::std::option::Option::None;
        self.chat = ::std::option::Option::None;
        self.msg_name.clear();
        self.params.clear();
        self.textallchat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SayText2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SayText2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_TextMsg {
    // message fields
    msg_dst: ::std::option::Option<i32>,
    pub params: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_TextMsg {
    fn default() -> &'a CCSUsrMsg_TextMsg {
        <CCSUsrMsg_TextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_TextMsg {
    pub fn new() -> CCSUsrMsg_TextMsg {
        ::std::default::Default::default()
    }

    // optional int32 msg_dst = 1;


    pub fn get_msg_dst(&self) -> i32 {
        self.msg_dst.unwrap_or(0)
    }
    pub fn clear_msg_dst(&mut self) {
        self.msg_dst = ::std::option::Option::None;
    }

    pub fn has_msg_dst(&self) -> bool {
        self.msg_dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_dst(&mut self, v: i32) {
        self.msg_dst = ::std::option::Option::Some(v);
    }

    // repeated string params = 3;


    pub fn get_params(&self) -> &[::std::string::String] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_TextMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.msg_dst = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_dst {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_dst {
            os.write_int32(1, v)?;
        }
        for v in &self.params {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_TextMsg {
        CCSUsrMsg_TextMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "msg_dst",
                |m: &CCSUsrMsg_TextMsg| { &m.msg_dst },
                |m: &mut CCSUsrMsg_TextMsg| { &mut m.msg_dst },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "params",
                |m: &CCSUsrMsg_TextMsg| { &m.params },
                |m: &mut CCSUsrMsg_TextMsg| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_TextMsg>(
                "CCSUsrMsg_TextMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_TextMsg {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_TextMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_TextMsg::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_TextMsg {
    fn clear(&mut self) {
        self.msg_dst = ::std::option::Option::None;
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_TextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_TextMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_HudMsg {
    // message fields
    channel: ::std::option::Option<i32>,
    pub pos: ::protobuf::SingularPtrField<super::netmessages::CMsgVector2D>,
    pub clr1: ::protobuf::SingularPtrField<super::netmessages::CMsgRGBA>,
    pub clr2: ::protobuf::SingularPtrField<super::netmessages::CMsgRGBA>,
    effect: ::std::option::Option<i32>,
    fade_in_time: ::std::option::Option<f32>,
    fade_out_time: ::std::option::Option<f32>,
    hold_time: ::std::option::Option<f32>,
    fx_time: ::std::option::Option<f32>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HudMsg {
    fn default() -> &'a CCSUsrMsg_HudMsg {
        <CCSUsrMsg_HudMsg as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HudMsg {
    pub fn new() -> CCSUsrMsg_HudMsg {
        ::std::default::Default::default()
    }

    // optional int32 channel = 1;


    pub fn get_channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }
    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .CMsgVector2D pos = 2;


    pub fn get_pos(&self) -> &super::netmessages::CMsgVector2D {
        self.pos.as_ref().unwrap_or_else(|| <super::netmessages::CMsgVector2D as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pos(&mut self) {
        self.pos.clear();
    }

    pub fn has_pos(&self) -> bool {
        self.pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos(&mut self, v: super::netmessages::CMsgVector2D) {
        self.pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pos(&mut self) -> &mut super::netmessages::CMsgVector2D {
        if self.pos.is_none() {
            self.pos.set_default();
        }
        self.pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_pos(&mut self) -> super::netmessages::CMsgVector2D {
        self.pos.take().unwrap_or_else(|| super::netmessages::CMsgVector2D::new())
    }

    // optional .CMsgRGBA clr1 = 3;


    pub fn get_clr1(&self) -> &super::netmessages::CMsgRGBA {
        self.clr1.as_ref().unwrap_or_else(|| <super::netmessages::CMsgRGBA as ::protobuf::Message>::default_instance())
    }
    pub fn clear_clr1(&mut self) {
        self.clr1.clear();
    }

    pub fn has_clr1(&self) -> bool {
        self.clr1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clr1(&mut self, v: super::netmessages::CMsgRGBA) {
        self.clr1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clr1(&mut self) -> &mut super::netmessages::CMsgRGBA {
        if self.clr1.is_none() {
            self.clr1.set_default();
        }
        self.clr1.as_mut().unwrap()
    }

    // Take field
    pub fn take_clr1(&mut self) -> super::netmessages::CMsgRGBA {
        self.clr1.take().unwrap_or_else(|| super::netmessages::CMsgRGBA::new())
    }

    // optional .CMsgRGBA clr2 = 4;


    pub fn get_clr2(&self) -> &super::netmessages::CMsgRGBA {
        self.clr2.as_ref().unwrap_or_else(|| <super::netmessages::CMsgRGBA as ::protobuf::Message>::default_instance())
    }
    pub fn clear_clr2(&mut self) {
        self.clr2.clear();
    }

    pub fn has_clr2(&self) -> bool {
        self.clr2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clr2(&mut self, v: super::netmessages::CMsgRGBA) {
        self.clr2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clr2(&mut self) -> &mut super::netmessages::CMsgRGBA {
        if self.clr2.is_none() {
            self.clr2.set_default();
        }
        self.clr2.as_mut().unwrap()
    }

    // Take field
    pub fn take_clr2(&mut self) -> super::netmessages::CMsgRGBA {
        self.clr2.take().unwrap_or_else(|| super::netmessages::CMsgRGBA::new())
    }

    // optional int32 effect = 5;


    pub fn get_effect(&self) -> i32 {
        self.effect.unwrap_or(0)
    }
    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: i32) {
        self.effect = ::std::option::Option::Some(v);
    }

    // optional float fade_in_time = 6;


    pub fn get_fade_in_time(&self) -> f32 {
        self.fade_in_time.unwrap_or(0.)
    }
    pub fn clear_fade_in_time(&mut self) {
        self.fade_in_time = ::std::option::Option::None;
    }

    pub fn has_fade_in_time(&self) -> bool {
        self.fade_in_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_in_time(&mut self, v: f32) {
        self.fade_in_time = ::std::option::Option::Some(v);
    }

    // optional float fade_out_time = 7;


    pub fn get_fade_out_time(&self) -> f32 {
        self.fade_out_time.unwrap_or(0.)
    }
    pub fn clear_fade_out_time(&mut self) {
        self.fade_out_time = ::std::option::Option::None;
    }

    pub fn has_fade_out_time(&self) -> bool {
        self.fade_out_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_out_time(&mut self, v: f32) {
        self.fade_out_time = ::std::option::Option::Some(v);
    }

    // optional float hold_time = 9;


    pub fn get_hold_time(&self) -> f32 {
        self.hold_time.unwrap_or(0.)
    }
    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: f32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional float fx_time = 10;


    pub fn get_fx_time(&self) -> f32 {
        self.fx_time.unwrap_or(0.)
    }
    pub fn clear_fx_time(&mut self) {
        self.fx_time = ::std::option::Option::None;
    }

    pub fn has_fx_time(&self) -> bool {
        self.fx_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fx_time(&mut self, v: f32) {
        self.fx_time = ::std::option::Option::Some(v);
    }

    // optional string text = 11;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_HudMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.pos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clr1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clr2 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.channel = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pos)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clr1)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clr2)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.effect = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fade_in_time = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fade_out_time = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.hold_time = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fx_time = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clr1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clr2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fade_in_time {
            my_size += 5;
        }
        if let Some(v) = self.fade_out_time {
            my_size += 5;
        }
        if let Some(v) = self.hold_time {
            my_size += 5;
        }
        if let Some(v) = self.fx_time {
            my_size += 5;
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.pos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clr1.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clr2.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.effect {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.fade_in_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.fade_out_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.fx_time {
            os.write_float(10, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_HudMsg {
        CCSUsrMsg_HudMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "channel",
                |m: &CCSUsrMsg_HudMsg| { &m.channel },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgVector2D>>(
                "pos",
                |m: &CCSUsrMsg_HudMsg| { &m.pos },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgRGBA>>(
                "clr1",
                |m: &CCSUsrMsg_HudMsg| { &m.clr1 },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.clr1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgRGBA>>(
                "clr2",
                |m: &CCSUsrMsg_HudMsg| { &m.clr2 },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.clr2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "effect",
                |m: &CCSUsrMsg_HudMsg| { &m.effect },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.effect },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fade_in_time",
                |m: &CCSUsrMsg_HudMsg| { &m.fade_in_time },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.fade_in_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fade_out_time",
                |m: &CCSUsrMsg_HudMsg| { &m.fade_out_time },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.fade_out_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "hold_time",
                |m: &CCSUsrMsg_HudMsg| { &m.hold_time },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.hold_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fx_time",
                |m: &CCSUsrMsg_HudMsg| { &m.fx_time },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.fx_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &CCSUsrMsg_HudMsg| { &m.text },
                |m: &mut CCSUsrMsg_HudMsg| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_HudMsg>(
                "CCSUsrMsg_HudMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_HudMsg {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_HudMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_HudMsg::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_HudMsg {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.pos.clear();
        self.clr1.clear();
        self.clr2.clear();
        self.effect = ::std::option::Option::None;
        self.fade_in_time = ::std::option::Option::None;
        self.fade_out_time = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.fx_time = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_HudMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HudMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Shake {
    // message fields
    command: ::std::option::Option<i32>,
    local_amplitude: ::std::option::Option<f32>,
    frequency: ::std::option::Option<f32>,
    duration: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Shake {
    fn default() -> &'a CCSUsrMsg_Shake {
        <CCSUsrMsg_Shake as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Shake {
    pub fn new() -> CCSUsrMsg_Shake {
        ::std::default::Default::default()
    }

    // optional int32 command = 1;


    pub fn get_command(&self) -> i32 {
        self.command.unwrap_or(0)
    }
    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: i32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float local_amplitude = 2;


    pub fn get_local_amplitude(&self) -> f32 {
        self.local_amplitude.unwrap_or(0.)
    }
    pub fn clear_local_amplitude(&mut self) {
        self.local_amplitude = ::std::option::Option::None;
    }

    pub fn has_local_amplitude(&self) -> bool {
        self.local_amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_amplitude(&mut self, v: f32) {
        self.local_amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;


    pub fn get_frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }
    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;


    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Shake {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.command = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.local_amplitude = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.frequency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.local_amplitude {
            my_size += 5;
        }
        if let Some(v) = self.frequency {
            my_size += 5;
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.command {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.local_amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Shake {
        CCSUsrMsg_Shake::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "command",
                |m: &CCSUsrMsg_Shake| { &m.command },
                |m: &mut CCSUsrMsg_Shake| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "local_amplitude",
                |m: &CCSUsrMsg_Shake| { &m.local_amplitude },
                |m: &mut CCSUsrMsg_Shake| { &mut m.local_amplitude },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "frequency",
                |m: &CCSUsrMsg_Shake| { &m.frequency },
                |m: &mut CCSUsrMsg_Shake| { &mut m.frequency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "duration",
                |m: &CCSUsrMsg_Shake| { &m.duration },
                |m: &mut CCSUsrMsg_Shake| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_Shake>(
                "CCSUsrMsg_Shake",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_Shake {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_Shake> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_Shake::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Shake {
    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.local_amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Shake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Shake {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Fade {
    // message fields
    duration: ::std::option::Option<i32>,
    hold_time: ::std::option::Option<i32>,
    flags: ::std::option::Option<i32>,
    pub clr: ::protobuf::SingularPtrField<super::netmessages::CMsgRGBA>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Fade {
    fn default() -> &'a CCSUsrMsg_Fade {
        <CCSUsrMsg_Fade as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Fade {
    pub fn new() -> CCSUsrMsg_Fade {
        ::std::default::Default::default()
    }

    // optional int32 duration = 1;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 hold_time = 2;


    pub fn get_hold_time(&self) -> i32 {
        self.hold_time.unwrap_or(0)
    }
    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: i32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;


    pub fn get_flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional .CMsgRGBA clr = 4;


    pub fn get_clr(&self) -> &super::netmessages::CMsgRGBA {
        self.clr.as_ref().unwrap_or_else(|| <super::netmessages::CMsgRGBA as ::protobuf::Message>::default_instance())
    }
    pub fn clear_clr(&mut self) {
        self.clr.clear();
    }

    pub fn has_clr(&self) -> bool {
        self.clr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clr(&mut self, v: super::netmessages::CMsgRGBA) {
        self.clr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clr(&mut self) -> &mut super::netmessages::CMsgRGBA {
        if self.clr.is_none() {
            self.clr.set_default();
        }
        self.clr.as_mut().unwrap()
    }

    // Take field
    pub fn take_clr(&mut self) -> super::netmessages::CMsgRGBA {
        self.clr.take().unwrap_or_else(|| super::netmessages::CMsgRGBA::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_Fade {
    fn is_initialized(&self) -> bool {
        for v in &self.clr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hold_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hold_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.duration {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.clr.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Fade {
        CCSUsrMsg_Fade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &CCSUsrMsg_Fade| { &m.duration },
                |m: &mut CCSUsrMsg_Fade| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "hold_time",
                |m: &CCSUsrMsg_Fade| { &m.hold_time },
                |m: &mut CCSUsrMsg_Fade| { &mut m.hold_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "flags",
                |m: &CCSUsrMsg_Fade| { &m.flags },
                |m: &mut CCSUsrMsg_Fade| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgRGBA>>(
                "clr",
                |m: &CCSUsrMsg_Fade| { &m.clr },
                |m: &mut CCSUsrMsg_Fade| { &mut m.clr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_Fade>(
                "CCSUsrMsg_Fade",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_Fade {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_Fade> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_Fade::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Fade {
    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.clr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Fade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Fade {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Rumble {
    // message fields
    index: ::std::option::Option<i32>,
    data: ::std::option::Option<i32>,
    flags: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Rumble {
    fn default() -> &'a CCSUsrMsg_Rumble {
        <CCSUsrMsg_Rumble as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Rumble {
    pub fn new() -> CCSUsrMsg_Rumble {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;


    pub fn get_data(&self) -> i32 {
        self.data.unwrap_or(0)
    }
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;


    pub fn get_flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Rumble {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.data = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Rumble {
        CCSUsrMsg_Rumble::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &CCSUsrMsg_Rumble| { &m.index },
                |m: &mut CCSUsrMsg_Rumble| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "data",
                |m: &CCSUsrMsg_Rumble| { &m.data },
                |m: &mut CCSUsrMsg_Rumble| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "flags",
                |m: &CCSUsrMsg_Rumble| { &m.flags },
                |m: &mut CCSUsrMsg_Rumble| { &mut m.flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_Rumble>(
                "CCSUsrMsg_Rumble",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_Rumble {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_Rumble> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_Rumble::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Rumble {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Rumble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Rumble {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CloseCaption {
    // message fields
    hash: ::std::option::Option<u32>,
    duration: ::std::option::Option<i32>,
    from_player: ::std::option::Option<bool>,
    cctoken: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CloseCaption {
    fn default() -> &'a CCSUsrMsg_CloseCaption {
        <CCSUsrMsg_CloseCaption as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CloseCaption {
    pub fn new() -> CCSUsrMsg_CloseCaption {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;


    pub fn get_hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }
    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;


    pub fn get_from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }
    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional string cctoken = 4;


    pub fn get_cctoken(&self) -> &str {
        match self.cctoken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cctoken(&mut self) {
        self.cctoken.clear();
    }

    pub fn has_cctoken(&self) -> bool {
        self.cctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cctoken(&mut self, v: ::std::string::String) {
        self.cctoken = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cctoken(&mut self) -> &mut ::std::string::String {
        if self.cctoken.is_none() {
            self.cctoken.set_default();
        }
        self.cctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_cctoken(&mut self) -> ::std::string::String {
        self.cctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_CloseCaption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hash = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.from_player = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cctoken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_player {
            my_size += 2;
        }
        if let Some(ref v) = self.cctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.cctoken.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CloseCaption {
        CCSUsrMsg_CloseCaption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hash",
                |m: &CCSUsrMsg_CloseCaption| { &m.hash },
                |m: &mut CCSUsrMsg_CloseCaption| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &CCSUsrMsg_CloseCaption| { &m.duration },
                |m: &mut CCSUsrMsg_CloseCaption| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "from_player",
                |m: &CCSUsrMsg_CloseCaption| { &m.from_player },
                |m: &mut CCSUsrMsg_CloseCaption| { &mut m.from_player },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cctoken",
                |m: &CCSUsrMsg_CloseCaption| { &m.cctoken },
                |m: &mut CCSUsrMsg_CloseCaption| { &mut m.cctoken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_CloseCaption>(
                "CCSUsrMsg_CloseCaption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_CloseCaption {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_CloseCaption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_CloseCaption::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CloseCaption {
    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.cctoken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CloseCaption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CloseCaption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CloseCaptionDirect {
    // message fields
    hash: ::std::option::Option<u32>,
    duration: ::std::option::Option<i32>,
    from_player: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CloseCaptionDirect {
    fn default() -> &'a CCSUsrMsg_CloseCaptionDirect {
        <CCSUsrMsg_CloseCaptionDirect as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CloseCaptionDirect {
    pub fn new() -> CCSUsrMsg_CloseCaptionDirect {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;


    pub fn get_hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }
    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;


    pub fn get_duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;


    pub fn get_from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }
    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_CloseCaptionDirect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hash = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.from_player = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_player {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CloseCaptionDirect {
        CCSUsrMsg_CloseCaptionDirect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hash",
                |m: &CCSUsrMsg_CloseCaptionDirect| { &m.hash },
                |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &CCSUsrMsg_CloseCaptionDirect| { &m.duration },
                |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "from_player",
                |m: &CCSUsrMsg_CloseCaptionDirect| { &m.from_player },
                |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.from_player },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_CloseCaptionDirect>(
                "CCSUsrMsg_CloseCaptionDirect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_CloseCaptionDirect {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_CloseCaptionDirect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_CloseCaptionDirect::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CloseCaptionDirect {
    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CloseCaptionDirect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CloseCaptionDirect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SendAudio {
    // message fields
    radio_sound: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendAudio {
    fn default() -> &'a CCSUsrMsg_SendAudio {
        <CCSUsrMsg_SendAudio as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendAudio {
    pub fn new() -> CCSUsrMsg_SendAudio {
        ::std::default::Default::default()
    }

    // optional string radio_sound = 1;


    pub fn get_radio_sound(&self) -> &str {
        match self.radio_sound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_radio_sound(&mut self) {
        self.radio_sound.clear();
    }

    pub fn has_radio_sound(&self) -> bool {
        self.radio_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_sound(&mut self, v: ::std::string::String) {
        self.radio_sound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radio_sound(&mut self) -> &mut ::std::string::String {
        if self.radio_sound.is_none() {
            self.radio_sound.set_default();
        }
        self.radio_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_radio_sound(&mut self) -> ::std::string::String {
        self.radio_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendAudio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.radio_sound)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.radio_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.radio_sound.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SendAudio {
        CCSUsrMsg_SendAudio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "radio_sound",
                |m: &CCSUsrMsg_SendAudio| { &m.radio_sound },
                |m: &mut CCSUsrMsg_SendAudio| { &mut m.radio_sound },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SendAudio>(
                "CCSUsrMsg_SendAudio",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SendAudio {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SendAudio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SendAudio::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SendAudio {
    fn clear(&mut self) {
        self.radio_sound.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SendAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendAudio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RawAudio {
    // message fields
    pitch: ::std::option::Option<i32>,
    entidx: ::std::option::Option<i32>,
    duration: ::std::option::Option<f32>,
    voice_filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RawAudio {
    fn default() -> &'a CCSUsrMsg_RawAudio {
        <CCSUsrMsg_RawAudio as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RawAudio {
    pub fn new() -> CCSUsrMsg_RawAudio {
        ::std::default::Default::default()
    }

    // optional int32 pitch = 1;


    pub fn get_pitch(&self) -> i32 {
        self.pitch.unwrap_or(0)
    }
    pub fn clear_pitch(&mut self) {
        self.pitch = ::std::option::Option::None;
    }

    pub fn has_pitch(&self) -> bool {
        self.pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: i32) {
        self.pitch = ::std::option::Option::Some(v);
    }

    // optional int32 entidx = 2;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;


    pub fn get_duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string voice_filename = 4;


    pub fn get_voice_filename(&self) -> &str {
        match self.voice_filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_voice_filename(&mut self) {
        self.voice_filename.clear();
    }

    pub fn has_voice_filename(&self) -> bool {
        self.voice_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_filename(&mut self, v: ::std::string::String) {
        self.voice_filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_filename(&mut self) -> &mut ::std::string::String {
        if self.voice_filename.is_none() {
            self.voice_filename.set_default();
        }
        self.voice_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_filename(&mut self) -> ::std::string::String {
        self.voice_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_RawAudio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pitch = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.voice_filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pitch {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration {
            my_size += 5;
        }
        if let Some(ref v) = self.voice_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pitch {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entidx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(ref v) = self.voice_filename.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RawAudio {
        CCSUsrMsg_RawAudio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pitch",
                |m: &CCSUsrMsg_RawAudio| { &m.pitch },
                |m: &mut CCSUsrMsg_RawAudio| { &mut m.pitch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entidx",
                |m: &CCSUsrMsg_RawAudio| { &m.entidx },
                |m: &mut CCSUsrMsg_RawAudio| { &mut m.entidx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "duration",
                |m: &CCSUsrMsg_RawAudio| { &m.duration },
                |m: &mut CCSUsrMsg_RawAudio| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "voice_filename",
                |m: &CCSUsrMsg_RawAudio| { &m.voice_filename },
                |m: &mut CCSUsrMsg_RawAudio| { &mut m.voice_filename },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RawAudio>(
                "CCSUsrMsg_RawAudio",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RawAudio {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RawAudio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RawAudio::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RawAudio {
    fn clear(&mut self) {
        self.pitch = ::std::option::Option::None;
        self.entidx = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.voice_filename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RawAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RawAudio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoiceMask {
    // message fields
    pub player_masks: ::protobuf::RepeatedField<CCSUsrMsg_VoiceMask_PlayerMask>,
    player_mod_enable: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoiceMask {
    fn default() -> &'a CCSUsrMsg_VoiceMask {
        <CCSUsrMsg_VoiceMask as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoiceMask {
    pub fn new() -> CCSUsrMsg_VoiceMask {
        ::std::default::Default::default()
    }

    // repeated .CCSUsrMsg_VoiceMask.PlayerMask player_masks = 1;


    pub fn get_player_masks(&self) -> &[CCSUsrMsg_VoiceMask_PlayerMask] {
        &self.player_masks
    }
    pub fn clear_player_masks(&mut self) {
        self.player_masks.clear();
    }

    // Param is passed by value, moved
    pub fn set_player_masks(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_VoiceMask_PlayerMask>) {
        self.player_masks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_player_masks(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_VoiceMask_PlayerMask> {
        &mut self.player_masks
    }

    // Take field
    pub fn take_player_masks(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_VoiceMask_PlayerMask> {
        ::std::mem::replace(&mut self.player_masks, ::protobuf::RepeatedField::new())
    }

    // optional bool player_mod_enable = 2;


    pub fn get_player_mod_enable(&self) -> bool {
        self.player_mod_enable.unwrap_or(false)
    }
    pub fn clear_player_mod_enable(&mut self) {
        self.player_mod_enable = ::std::option::Option::None;
    }

    pub fn has_player_mod_enable(&self) -> bool {
        self.player_mod_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mod_enable(&mut self, v: bool) {
        self.player_mod_enable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoiceMask {
    fn is_initialized(&self) -> bool {
        for v in &self.player_masks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.player_masks)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.player_mod_enable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.player_masks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.player_mod_enable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.player_masks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.player_mod_enable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoiceMask {
        CCSUsrMsg_VoiceMask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_VoiceMask_PlayerMask>>(
                "player_masks",
                |m: &CCSUsrMsg_VoiceMask| { &m.player_masks },
                |m: &mut CCSUsrMsg_VoiceMask| { &mut m.player_masks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "player_mod_enable",
                |m: &CCSUsrMsg_VoiceMask| { &m.player_mod_enable },
                |m: &mut CCSUsrMsg_VoiceMask| { &mut m.player_mod_enable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_VoiceMask>(
                "CCSUsrMsg_VoiceMask",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_VoiceMask {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_VoiceMask> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_VoiceMask::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoiceMask {
    fn clear(&mut self) {
        self.player_masks.clear();
        self.player_mod_enable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoiceMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoiceMask {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoiceMask_PlayerMask {
    // message fields
    game_rules_mask: ::std::option::Option<i32>,
    ban_masks: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoiceMask_PlayerMask {
    fn default() -> &'a CCSUsrMsg_VoiceMask_PlayerMask {
        <CCSUsrMsg_VoiceMask_PlayerMask as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoiceMask_PlayerMask {
    pub fn new() -> CCSUsrMsg_VoiceMask_PlayerMask {
        ::std::default::Default::default()
    }

    // optional int32 game_rules_mask = 1;


    pub fn get_game_rules_mask(&self) -> i32 {
        self.game_rules_mask.unwrap_or(0)
    }
    pub fn clear_game_rules_mask(&mut self) {
        self.game_rules_mask = ::std::option::Option::None;
    }

    pub fn has_game_rules_mask(&self) -> bool {
        self.game_rules_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_rules_mask(&mut self, v: i32) {
        self.game_rules_mask = ::std::option::Option::Some(v);
    }

    // optional int32 ban_masks = 2;


    pub fn get_ban_masks(&self) -> i32 {
        self.ban_masks.unwrap_or(0)
    }
    pub fn clear_ban_masks(&mut self) {
        self.ban_masks = ::std::option::Option::None;
    }

    pub fn has_ban_masks(&self) -> bool {
        self.ban_masks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_masks(&mut self, v: i32) {
        self.ban_masks = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoiceMask_PlayerMask {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_rules_mask = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ban_masks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_rules_mask {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ban_masks {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_rules_mask {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ban_masks {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoiceMask_PlayerMask {
        CCSUsrMsg_VoiceMask_PlayerMask::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_rules_mask",
                |m: &CCSUsrMsg_VoiceMask_PlayerMask| { &m.game_rules_mask },
                |m: &mut CCSUsrMsg_VoiceMask_PlayerMask| { &mut m.game_rules_mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ban_masks",
                |m: &CCSUsrMsg_VoiceMask_PlayerMask| { &m.ban_masks },
                |m: &mut CCSUsrMsg_VoiceMask_PlayerMask| { &mut m.ban_masks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_VoiceMask_PlayerMask>(
                "CCSUsrMsg_VoiceMask.PlayerMask",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_VoiceMask_PlayerMask {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_VoiceMask_PlayerMask> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_VoiceMask_PlayerMask::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoiceMask_PlayerMask {
    fn clear(&mut self) {
        self.game_rules_mask = ::std::option::Option::None;
        self.ban_masks = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoiceMask_PlayerMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoiceMask_PlayerMask {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_Damage {
    // message fields
    amount: ::std::option::Option<i32>,
    pub inflictor_world_pos: ::protobuf::SingularPtrField<super::netmessages::CMsgVector>,
    victim_entindex: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Damage {
    fn default() -> &'a CCSUsrMsg_Damage {
        <CCSUsrMsg_Damage as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Damage {
    pub fn new() -> CCSUsrMsg_Damage {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;


    pub fn get_amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional .CMsgVector inflictor_world_pos = 2;


    pub fn get_inflictor_world_pos(&self) -> &super::netmessages::CMsgVector {
        self.inflictor_world_pos.as_ref().unwrap_or_else(|| <super::netmessages::CMsgVector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_inflictor_world_pos(&mut self) {
        self.inflictor_world_pos.clear();
    }

    pub fn has_inflictor_world_pos(&self) -> bool {
        self.inflictor_world_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inflictor_world_pos(&mut self, v: super::netmessages::CMsgVector) {
        self.inflictor_world_pos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inflictor_world_pos(&mut self) -> &mut super::netmessages::CMsgVector {
        if self.inflictor_world_pos.is_none() {
            self.inflictor_world_pos.set_default();
        }
        self.inflictor_world_pos.as_mut().unwrap()
    }

    // Take field
    pub fn take_inflictor_world_pos(&mut self) -> super::netmessages::CMsgVector {
        self.inflictor_world_pos.take().unwrap_or_else(|| super::netmessages::CMsgVector::new())
    }

    // optional int32 victim_entindex = 3;


    pub fn get_victim_entindex(&self) -> i32 {
        self.victim_entindex.unwrap_or(0)
    }
    pub fn clear_victim_entindex(&mut self) {
        self.victim_entindex = ::std::option::Option::None;
    }

    pub fn has_victim_entindex(&self) -> bool {
        self.victim_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_entindex(&mut self, v: i32) {
        self.victim_entindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_Damage {
    fn is_initialized(&self) -> bool {
        for v in &self.inflictor_world_pos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inflictor_world_pos)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.victim_entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.inflictor_world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.victim_entindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.inflictor_world_pos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.victim_entindex {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_Damage {
        CCSUsrMsg_Damage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "amount",
                |m: &CCSUsrMsg_Damage| { &m.amount },
                |m: &mut CCSUsrMsg_Damage| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::netmessages::CMsgVector>>(
                "inflictor_world_pos",
                |m: &CCSUsrMsg_Damage| { &m.inflictor_world_pos },
                |m: &mut CCSUsrMsg_Damage| { &mut m.inflictor_world_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "victim_entindex",
                |m: &CCSUsrMsg_Damage| { &m.victim_entindex },
                |m: &mut CCSUsrMsg_Damage| { &mut m.victim_entindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_Damage>(
                "CCSUsrMsg_Damage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_Damage {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_Damage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_Damage::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_Damage {
    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.inflictor_world_pos.clear();
        self.victim_entindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_Damage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Damage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RadioText {
    // message fields
    msg_dst: ::std::option::Option<i32>,
    client: ::std::option::Option<i32>,
    msg_name: ::protobuf::SingularField<::std::string::String>,
    pub params: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RadioText {
    fn default() -> &'a CCSUsrMsg_RadioText {
        <CCSUsrMsg_RadioText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RadioText {
    pub fn new() -> CCSUsrMsg_RadioText {
        ::std::default::Default::default()
    }

    // optional int32 msg_dst = 1;


    pub fn get_msg_dst(&self) -> i32 {
        self.msg_dst.unwrap_or(0)
    }
    pub fn clear_msg_dst(&mut self) {
        self.msg_dst = ::std::option::Option::None;
    }

    pub fn has_msg_dst(&self) -> bool {
        self.msg_dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_dst(&mut self, v: i32) {
        self.msg_dst = ::std::option::Option::Some(v);
    }

    // optional int32 client = 2;


    pub fn get_client(&self) -> i32 {
        self.client.unwrap_or(0)
    }
    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional string msg_name = 3;


    pub fn get_msg_name(&self) -> &str {
        match self.msg_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_msg_name(&mut self) {
        self.msg_name.clear();
    }

    pub fn has_msg_name(&self) -> bool {
        self.msg_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_name(&mut self, v: ::std::string::String) {
        self.msg_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_name(&mut self) -> &mut ::std::string::String {
        if self.msg_name.is_none() {
            self.msg_name.set_default();
        }
        self.msg_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_name(&mut self) -> ::std::string::String {
        self.msg_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string params = 4;


    pub fn get_params(&self) -> &[::std::string::String] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_RadioText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.msg_dst = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.client = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.msg_name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.params)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_dst {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.client {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.msg_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_dst {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.client {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.msg_name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.params {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RadioText {
        CCSUsrMsg_RadioText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "msg_dst",
                |m: &CCSUsrMsg_RadioText| { &m.msg_dst },
                |m: &mut CCSUsrMsg_RadioText| { &mut m.msg_dst },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "client",
                |m: &CCSUsrMsg_RadioText| { &m.client },
                |m: &mut CCSUsrMsg_RadioText| { &mut m.client },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "msg_name",
                |m: &CCSUsrMsg_RadioText| { &m.msg_name },
                |m: &mut CCSUsrMsg_RadioText| { &mut m.msg_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "params",
                |m: &CCSUsrMsg_RadioText| { &m.params },
                |m: &mut CCSUsrMsg_RadioText| { &mut m.params },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RadioText>(
                "CCSUsrMsg_RadioText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RadioText {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RadioText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RadioText::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RadioText {
    fn clear(&mut self) {
        self.msg_dst = ::std::option::Option::None;
        self.client = ::std::option::Option::None;
        self.msg_name.clear();
        self.params.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RadioText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RadioText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_HintText {
    // message fields
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HintText {
    fn default() -> &'a CCSUsrMsg_HintText {
        <CCSUsrMsg_HintText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HintText {
    pub fn new() -> CCSUsrMsg_HintText {
        ::std::default::Default::default()
    }

    // optional string text = 1;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_HintText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_HintText {
        CCSUsrMsg_HintText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &CCSUsrMsg_HintText| { &m.text },
                |m: &mut CCSUsrMsg_HintText| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_HintText>(
                "CCSUsrMsg_HintText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_HintText {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_HintText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_HintText::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_HintText {
    fn clear(&mut self) {
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_HintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HintText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_KeyHintText {
    // message fields
    pub hints: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_KeyHintText {
    fn default() -> &'a CCSUsrMsg_KeyHintText {
        <CCSUsrMsg_KeyHintText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_KeyHintText {
    pub fn new() -> CCSUsrMsg_KeyHintText {
        ::std::default::Default::default()
    }

    // repeated string hints = 1;


    pub fn get_hints(&self) -> &[::std::string::String] {
        &self.hints
    }
    pub fn clear_hints(&mut self) {
        self.hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_hints(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hints(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hints
    }

    // Take field
    pub fn take_hints(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_KeyHintText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hints {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hints {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_KeyHintText {
        CCSUsrMsg_KeyHintText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hints",
                |m: &CCSUsrMsg_KeyHintText| { &m.hints },
                |m: &mut CCSUsrMsg_KeyHintText| { &mut m.hints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_KeyHintText>(
                "CCSUsrMsg_KeyHintText",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_KeyHintText {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_KeyHintText> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_KeyHintText::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_KeyHintText {
    fn clear(&mut self) {
        self.hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_KeyHintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_KeyHintText {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ProcessSpottedEntityUpdate {
    // message fields
    new_update: ::std::option::Option<bool>,
    pub entity_updates: ::protobuf::RepeatedField<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn default() -> &'a CCSUsrMsg_ProcessSpottedEntityUpdate {
        <CCSUsrMsg_ProcessSpottedEntityUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ProcessSpottedEntityUpdate {
    pub fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate {
        ::std::default::Default::default()
    }

    // optional bool new_update = 1;


    pub fn get_new_update(&self) -> bool {
        self.new_update.unwrap_or(false)
    }
    pub fn clear_new_update(&mut self) {
        self.new_update = ::std::option::Option::None;
    }

    pub fn has_new_update(&self) -> bool {
        self.new_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_update(&mut self, v: bool) {
        self.new_update = ::std::option::Option::Some(v);
    }

    // repeated .CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate entity_updates = 2;


    pub fn get_entity_updates(&self) -> &[CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate] {
        &self.entity_updates
    }
    pub fn clear_entity_updates(&mut self) {
        self.entity_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_updates(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate>) {
        self.entity_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entity_updates(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate> {
        &mut self.entity_updates
    }

    // Take field
    pub fn take_entity_updates(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate> {
        ::std::mem::replace(&mut self.entity_updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.entity_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.new_update = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entity_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.new_update {
            my_size += 2;
        }
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.new_update {
            os.write_bool(1, v)?;
        }
        for v in &self.entity_updates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate {
        CCSUsrMsg_ProcessSpottedEntityUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "new_update",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate| { &m.new_update },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate| { &mut m.new_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate>>(
                "entity_updates",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate| { &m.entity_updates },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate| { &mut m.entity_updates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ProcessSpottedEntityUpdate>(
                "CCSUsrMsg_ProcessSpottedEntityUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ProcessSpottedEntityUpdate {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ProcessSpottedEntityUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ProcessSpottedEntityUpdate::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn clear(&mut self) {
        self.new_update = ::std::option::Option::None;
        self.entity_updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    // message fields
    entity_idx: ::std::option::Option<i32>,
    class_id: ::std::option::Option<i32>,
    origin_x: ::std::option::Option<i32>,
    origin_y: ::std::option::Option<i32>,
    origin_z: ::std::option::Option<i32>,
    angle_y: ::std::option::Option<i32>,
    defuser: ::std::option::Option<bool>,
    player_has_defuser: ::std::option::Option<bool>,
    player_has_c4: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn default() -> &'a CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
        <CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    pub fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
        ::std::default::Default::default()
    }

    // optional int32 entity_idx = 1;


    pub fn get_entity_idx(&self) -> i32 {
        self.entity_idx.unwrap_or(0)
    }
    pub fn clear_entity_idx(&mut self) {
        self.entity_idx = ::std::option::Option::None;
    }

    pub fn has_entity_idx(&self) -> bool {
        self.entity_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_idx(&mut self, v: i32) {
        self.entity_idx = ::std::option::Option::Some(v);
    }

    // optional int32 class_id = 2;


    pub fn get_class_id(&self) -> i32 {
        self.class_id.unwrap_or(0)
    }
    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: i32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional int32 origin_x = 3;


    pub fn get_origin_x(&self) -> i32 {
        self.origin_x.unwrap_or(0)
    }
    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: i32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional int32 origin_y = 4;


    pub fn get_origin_y(&self) -> i32 {
        self.origin_y.unwrap_or(0)
    }
    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: i32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional int32 origin_z = 5;


    pub fn get_origin_z(&self) -> i32 {
        self.origin_z.unwrap_or(0)
    }
    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: i32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    // optional int32 angle_y = 6;


    pub fn get_angle_y(&self) -> i32 {
        self.angle_y.unwrap_or(0)
    }
    pub fn clear_angle_y(&mut self) {
        self.angle_y = ::std::option::Option::None;
    }

    pub fn has_angle_y(&self) -> bool {
        self.angle_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_angle_y(&mut self, v: i32) {
        self.angle_y = ::std::option::Option::Some(v);
    }

    // optional bool defuser = 7;


    pub fn get_defuser(&self) -> bool {
        self.defuser.unwrap_or(false)
    }
    pub fn clear_defuser(&mut self) {
        self.defuser = ::std::option::Option::None;
    }

    pub fn has_defuser(&self) -> bool {
        self.defuser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defuser(&mut self, v: bool) {
        self.defuser = ::std::option::Option::Some(v);
    }

    // optional bool player_has_defuser = 8;


    pub fn get_player_has_defuser(&self) -> bool {
        self.player_has_defuser.unwrap_or(false)
    }
    pub fn clear_player_has_defuser(&mut self) {
        self.player_has_defuser = ::std::option::Option::None;
    }

    pub fn has_player_has_defuser(&self) -> bool {
        self.player_has_defuser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_has_defuser(&mut self, v: bool) {
        self.player_has_defuser = ::std::option::Option::Some(v);
    }

    // optional bool player_has_c4 = 9;


    pub fn get_player_has_c4(&self) -> bool {
        self.player_has_c4.unwrap_or(false)
    }
    pub fn clear_player_has_c4(&mut self) {
        self.player_has_c4 = ::std::option::Option::None;
    }

    pub fn has_player_has_c4(&self) -> bool {
        self.player_has_c4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_has_c4(&mut self, v: bool) {
        self.player_has_c4 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entity_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.class_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.origin_x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.origin_y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.origin_z = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.angle_y = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.defuser = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.player_has_defuser = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.player_has_c4 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entity_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_x {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_y {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_z {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.angle_y {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defuser {
            my_size += 2;
        }
        if let Some(v) = self.player_has_defuser {
            my_size += 2;
        }
        if let Some(v) = self.player_has_c4 {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entity_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.angle_y {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.defuser {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.player_has_defuser {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.player_has_c4 {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
        CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entity_idx",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.entity_idx },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.entity_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "class_id",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.class_id },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "origin_x",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.origin_x },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.origin_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "origin_y",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.origin_y },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.origin_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "origin_z",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.origin_z },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.origin_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "angle_y",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.angle_y },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.angle_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "defuser",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.defuser },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.defuser },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "player_has_defuser",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.player_has_defuser },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.player_has_defuser },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "player_has_c4",
                |m: &CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &m.player_has_c4 },
                |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate| { &mut m.player_has_c4 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate>(
                "CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn clear(&mut self) {
        self.entity_idx = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.angle_y = ::std::option::Option::None;
        self.defuser = ::std::option::Option::None;
        self.player_has_defuser = ::std::option::Option::None;
        self.player_has_c4 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ProcessSpottedEntityUpdate_SpottedEntityUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SendPlayerItemDrops {
    // message fields
    pub entity_updates: ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendPlayerItemDrops {
    fn default() -> &'a CCSUsrMsg_SendPlayerItemDrops {
        <CCSUsrMsg_SendPlayerItemDrops as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendPlayerItemDrops {
    pub fn new() -> CCSUsrMsg_SendPlayerItemDrops {
        ::std::default::Default::default()
    }

    // repeated .CEconItemPreviewDataBlock entity_updates = 1;


    pub fn get_entity_updates(&self) -> &[super::cstrike15_gcmessages::CEconItemPreviewDataBlock] {
        &self.entity_updates
    }
    pub fn clear_entity_updates(&mut self) {
        self.entity_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_updates(&mut self, v: ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>) {
        self.entity_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entity_updates(&mut self) -> &mut ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock> {
        &mut self.entity_updates
    }

    // Take field
    pub fn take_entity_updates(&mut self) -> ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock> {
        ::std::mem::replace(&mut self.entity_updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendPlayerItemDrops {
    fn is_initialized(&self) -> bool {
        for v in &self.entity_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entity_updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entity_updates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SendPlayerItemDrops {
        CCSUsrMsg_SendPlayerItemDrops::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>>(
                "entity_updates",
                |m: &CCSUsrMsg_SendPlayerItemDrops| { &m.entity_updates },
                |m: &mut CCSUsrMsg_SendPlayerItemDrops| { &mut m.entity_updates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SendPlayerItemDrops>(
                "CCSUsrMsg_SendPlayerItemDrops",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SendPlayerItemDrops {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SendPlayerItemDrops> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SendPlayerItemDrops::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SendPlayerItemDrops {
    fn clear(&mut self) {
        self.entity_updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SendPlayerItemDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendPlayerItemDrops {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SendPlayerItemFound {
    // message fields
    pub iteminfo: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    entindex: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendPlayerItemFound {
    fn default() -> &'a CCSUsrMsg_SendPlayerItemFound {
        <CCSUsrMsg_SendPlayerItemFound as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendPlayerItemFound {
    pub fn new() -> CCSUsrMsg_SendPlayerItemFound {
        ::std::default::Default::default()
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 1;


    pub fn get_iteminfo(&self) -> &super::cstrike15_gcmessages::CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| <super::cstrike15_gcmessages::CEconItemPreviewDataBlock as ::protobuf::Message>::default_instance())
    }
    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: super::cstrike15_gcmessages::CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut super::cstrike15_gcmessages::CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> super::cstrike15_gcmessages::CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| super::cstrike15_gcmessages::CEconItemPreviewDataBlock::new())
    }

    // optional int32 entindex = 2;


    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }
    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendPlayerItemFound {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SendPlayerItemFound {
        CCSUsrMsg_SendPlayerItemFound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>>(
                "iteminfo",
                |m: &CCSUsrMsg_SendPlayerItemFound| { &m.iteminfo },
                |m: &mut CCSUsrMsg_SendPlayerItemFound| { &mut m.iteminfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entindex",
                |m: &CCSUsrMsg_SendPlayerItemFound| { &m.entindex },
                |m: &mut CCSUsrMsg_SendPlayerItemFound| { &mut m.entindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SendPlayerItemFound>(
                "CCSUsrMsg_SendPlayerItemFound",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SendPlayerItemFound {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SendPlayerItemFound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SendPlayerItemFound::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SendPlayerItemFound {
    fn clear(&mut self) {
        self.iteminfo.clear();
        self.entindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SendPlayerItemFound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendPlayerItemFound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ReloadEffect {
    // message fields
    entidx: ::std::option::Option<i32>,
    actanim: ::std::option::Option<i32>,
    origin_x: ::std::option::Option<f32>,
    origin_y: ::std::option::Option<f32>,
    origin_z: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ReloadEffect {
    fn default() -> &'a CCSUsrMsg_ReloadEffect {
        <CCSUsrMsg_ReloadEffect as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ReloadEffect {
    pub fn new() -> CCSUsrMsg_ReloadEffect {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional int32 actanim = 2;


    pub fn get_actanim(&self) -> i32 {
        self.actanim.unwrap_or(0)
    }
    pub fn clear_actanim(&mut self) {
        self.actanim = ::std::option::Option::None;
    }

    pub fn has_actanim(&self) -> bool {
        self.actanim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actanim(&mut self, v: i32) {
        self.actanim = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 3;


    pub fn get_origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }
    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 4;


    pub fn get_origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }
    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 5;


    pub fn get_origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }
    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ReloadEffect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.actanim = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_x = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_y = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.actanim {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_x {
            my_size += 5;
        }
        if let Some(v) = self.origin_y {
            my_size += 5;
        }
        if let Some(v) = self.origin_z {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.actanim {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ReloadEffect {
        CCSUsrMsg_ReloadEffect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entidx",
                |m: &CCSUsrMsg_ReloadEffect| { &m.entidx },
                |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.entidx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "actanim",
                |m: &CCSUsrMsg_ReloadEffect| { &m.actanim },
                |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.actanim },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "origin_x",
                |m: &CCSUsrMsg_ReloadEffect| { &m.origin_x },
                |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "origin_y",
                |m: &CCSUsrMsg_ReloadEffect| { &m.origin_y },
                |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "origin_z",
                |m: &CCSUsrMsg_ReloadEffect| { &m.origin_z },
                |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ReloadEffect>(
                "CCSUsrMsg_ReloadEffect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ReloadEffect {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ReloadEffect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ReloadEffect::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ReloadEffect {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.actanim = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ReloadEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ReloadEffect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_WeaponSound {
    // message fields
    entidx: ::std::option::Option<i32>,
    origin_x: ::std::option::Option<f32>,
    origin_y: ::std::option::Option<f32>,
    origin_z: ::std::option::Option<f32>,
    sound: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_WeaponSound {
    fn default() -> &'a CCSUsrMsg_WeaponSound {
        <CCSUsrMsg_WeaponSound as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_WeaponSound {
    pub fn new() -> CCSUsrMsg_WeaponSound {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 2;


    pub fn get_origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }
    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 3;


    pub fn get_origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }
    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 4;


    pub fn get_origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }
    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    // optional string sound = 5;


    pub fn get_sound(&self) -> &str {
        match self.sound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sound(&mut self) {
        self.sound.clear();
    }

    pub fn has_sound(&self) -> bool {
        self.sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound(&mut self, v: ::std::string::String) {
        self.sound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound(&mut self) -> &mut ::std::string::String {
        if self.sound.is_none() {
            self.sound.set_default();
        }
        self.sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_sound(&mut self) -> ::std::string::String {
        self.sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float timestamp = 6;


    pub fn get_timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_WeaponSound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.origin_z = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sound)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin_x {
            my_size += 5;
        }
        if let Some(v) = self.origin_y {
            my_size += 5;
        }
        if let Some(v) = self.origin_z {
            my_size += 5;
        }
        if let Some(ref v) = self.sound.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(4, v)?;
        }
        if let Some(ref v) = self.sound.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_WeaponSound {
        CCSUsrMsg_WeaponSound::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entidx",
                |m: &CCSUsrMsg_WeaponSound| { &m.entidx },
                |m: &mut CCSUsrMsg_WeaponSound| { &mut m.entidx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "origin_x",
                |m: &CCSUsrMsg_WeaponSound| { &m.origin_x },
                |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "origin_y",
                |m: &CCSUsrMsg_WeaponSound| { &m.origin_y },
                |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "origin_z",
                |m: &CCSUsrMsg_WeaponSound| { &m.origin_z },
                |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sound",
                |m: &CCSUsrMsg_WeaponSound| { &m.sound },
                |m: &mut CCSUsrMsg_WeaponSound| { &mut m.sound },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "timestamp",
                |m: &CCSUsrMsg_WeaponSound| { &m.timestamp },
                |m: &mut CCSUsrMsg_WeaponSound| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_WeaponSound>(
                "CCSUsrMsg_WeaponSound",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_WeaponSound {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_WeaponSound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_WeaponSound::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_WeaponSound {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.sound.clear();
        self.timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_WeaponSound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_WeaponSound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_UpdateScreenHealthBar {
    // message fields
    entidx: ::std::option::Option<i32>,
    healthratio_old: ::std::option::Option<f32>,
    healthratio_new: ::std::option::Option<f32>,
    style: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_UpdateScreenHealthBar {
    fn default() -> &'a CCSUsrMsg_UpdateScreenHealthBar {
        <CCSUsrMsg_UpdateScreenHealthBar as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_UpdateScreenHealthBar {
    pub fn new() -> CCSUsrMsg_UpdateScreenHealthBar {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float healthratio_old = 2;


    pub fn get_healthratio_old(&self) -> f32 {
        self.healthratio_old.unwrap_or(0.)
    }
    pub fn clear_healthratio_old(&mut self) {
        self.healthratio_old = ::std::option::Option::None;
    }

    pub fn has_healthratio_old(&self) -> bool {
        self.healthratio_old.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_old(&mut self, v: f32) {
        self.healthratio_old = ::std::option::Option::Some(v);
    }

    // optional float healthratio_new = 3;


    pub fn get_healthratio_new(&self) -> f32 {
        self.healthratio_new.unwrap_or(0.)
    }
    pub fn clear_healthratio_new(&mut self) {
        self.healthratio_new = ::std::option::Option::None;
    }

    pub fn has_healthratio_new(&self) -> bool {
        self.healthratio_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_new(&mut self, v: f32) {
        self.healthratio_new = ::std::option::Option::Some(v);
    }

    // optional int32 style = 4;


    pub fn get_style(&self) -> i32 {
        self.style.unwrap_or(0)
    }
    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: i32) {
        self.style = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_UpdateScreenHealthBar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.healthratio_old = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.healthratio_new = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.style = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healthratio_old {
            my_size += 5;
        }
        if let Some(v) = self.healthratio_new {
            my_size += 5;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.healthratio_old {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.healthratio_new {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.style {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_UpdateScreenHealthBar {
        CCSUsrMsg_UpdateScreenHealthBar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entidx",
                |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.entidx },
                |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.entidx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "healthratio_old",
                |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.healthratio_old },
                |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.healthratio_old },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "healthratio_new",
                |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.healthratio_new },
                |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.healthratio_new },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "style",
                |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.style },
                |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.style },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_UpdateScreenHealthBar>(
                "CCSUsrMsg_UpdateScreenHealthBar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_UpdateScreenHealthBar {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_UpdateScreenHealthBar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_UpdateScreenHealthBar::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_UpdateScreenHealthBar {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.healthratio_old = ::std::option::Option::None;
        self.healthratio_new = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_UpdateScreenHealthBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_UpdateScreenHealthBar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_EntityOutlineHighlight {
    // message fields
    entidx: ::std::option::Option<i32>,
    removehighlight: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EntityOutlineHighlight {
    fn default() -> &'a CCSUsrMsg_EntityOutlineHighlight {
        <CCSUsrMsg_EntityOutlineHighlight as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EntityOutlineHighlight {
    pub fn new() -> CCSUsrMsg_EntityOutlineHighlight {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional bool removehighlight = 2;


    pub fn get_removehighlight(&self) -> bool {
        self.removehighlight.unwrap_or(false)
    }
    pub fn clear_removehighlight(&mut self) {
        self.removehighlight = ::std::option::Option::None;
    }

    pub fn has_removehighlight(&self) -> bool {
        self.removehighlight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removehighlight(&mut self, v: bool) {
        self.removehighlight = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_EntityOutlineHighlight {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.removehighlight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.removehighlight {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.removehighlight {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_EntityOutlineHighlight {
        CCSUsrMsg_EntityOutlineHighlight::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entidx",
                |m: &CCSUsrMsg_EntityOutlineHighlight| { &m.entidx },
                |m: &mut CCSUsrMsg_EntityOutlineHighlight| { &mut m.entidx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "removehighlight",
                |m: &CCSUsrMsg_EntityOutlineHighlight| { &m.removehighlight },
                |m: &mut CCSUsrMsg_EntityOutlineHighlight| { &mut m.removehighlight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_EntityOutlineHighlight>(
                "CCSUsrMsg_EntityOutlineHighlight",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_EntityOutlineHighlight {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_EntityOutlineHighlight> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_EntityOutlineHighlight::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_EntityOutlineHighlight {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.removehighlight = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_EntityOutlineHighlight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_EntityOutlineHighlight {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_AdjustMoney {
    // message fields
    amount: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AdjustMoney {
    fn default() -> &'a CCSUsrMsg_AdjustMoney {
        <CCSUsrMsg_AdjustMoney as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AdjustMoney {
    pub fn new() -> CCSUsrMsg_AdjustMoney {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;


    pub fn get_amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_AdjustMoney {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_AdjustMoney {
        CCSUsrMsg_AdjustMoney::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "amount",
                |m: &CCSUsrMsg_AdjustMoney| { &m.amount },
                |m: &mut CCSUsrMsg_AdjustMoney| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_AdjustMoney>(
                "CCSUsrMsg_AdjustMoney",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_AdjustMoney {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_AdjustMoney> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_AdjustMoney::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_AdjustMoney {
    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_AdjustMoney {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AdjustMoney {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ReportHit {
    // message fields
    pos_x: ::std::option::Option<f32>,
    pos_y: ::std::option::Option<f32>,
    timestamp: ::std::option::Option<f32>,
    pos_z: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ReportHit {
    fn default() -> &'a CCSUsrMsg_ReportHit {
        <CCSUsrMsg_ReportHit as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ReportHit {
    pub fn new() -> CCSUsrMsg_ReportHit {
        ::std::default::Default::default()
    }

    // optional float pos_x = 1;


    pub fn get_pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 2;


    pub fn get_pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float timestamp = 4;


    pub fn get_timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 3;


    pub fn get_pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }
    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ReportHit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += 5;
        }
        if let Some(v) = self.pos_y {
            my_size += 5;
        }
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        if let Some(v) = self.pos_z {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pos_x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ReportHit {
        CCSUsrMsg_ReportHit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_x",
                |m: &CCSUsrMsg_ReportHit| { &m.pos_x },
                |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_y",
                |m: &CCSUsrMsg_ReportHit| { &m.pos_y },
                |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "timestamp",
                |m: &CCSUsrMsg_ReportHit| { &m.timestamp },
                |m: &mut CCSUsrMsg_ReportHit| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_z",
                |m: &CCSUsrMsg_ReportHit| { &m.pos_z },
                |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ReportHit>(
                "CCSUsrMsg_ReportHit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ReportHit {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ReportHit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ReportHit::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ReportHit {
    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ReportHit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ReportHit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_KillCam {
    // message fields
    obs_mode: ::std::option::Option<i32>,
    first_target: ::std::option::Option<i32>,
    second_target: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_KillCam {
    fn default() -> &'a CCSUsrMsg_KillCam {
        <CCSUsrMsg_KillCam as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_KillCam {
    pub fn new() -> CCSUsrMsg_KillCam {
        ::std::default::Default::default()
    }

    // optional int32 obs_mode = 1;


    pub fn get_obs_mode(&self) -> i32 {
        self.obs_mode.unwrap_or(0)
    }
    pub fn clear_obs_mode(&mut self) {
        self.obs_mode = ::std::option::Option::None;
    }

    pub fn has_obs_mode(&self) -> bool {
        self.obs_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obs_mode(&mut self, v: i32) {
        self.obs_mode = ::std::option::Option::Some(v);
    }

    // optional int32 first_target = 2;


    pub fn get_first_target(&self) -> i32 {
        self.first_target.unwrap_or(0)
    }
    pub fn clear_first_target(&mut self) {
        self.first_target = ::std::option::Option::None;
    }

    pub fn has_first_target(&self) -> bool {
        self.first_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_target(&mut self, v: i32) {
        self.first_target = ::std::option::Option::Some(v);
    }

    // optional int32 second_target = 3;


    pub fn get_second_target(&self) -> i32 {
        self.second_target.unwrap_or(0)
    }
    pub fn clear_second_target(&mut self) {
        self.second_target = ::std::option::Option::None;
    }

    pub fn has_second_target(&self) -> bool {
        self.second_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_second_target(&mut self, v: i32) {
        self.second_target = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_KillCam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.obs_mode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.first_target = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.second_target = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.obs_mode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.first_target {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.second_target {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.obs_mode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.first_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.second_target {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_KillCam {
        CCSUsrMsg_KillCam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "obs_mode",
                |m: &CCSUsrMsg_KillCam| { &m.obs_mode },
                |m: &mut CCSUsrMsg_KillCam| { &mut m.obs_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "first_target",
                |m: &CCSUsrMsg_KillCam| { &m.first_target },
                |m: &mut CCSUsrMsg_KillCam| { &mut m.first_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "second_target",
                |m: &CCSUsrMsg_KillCam| { &m.second_target },
                |m: &mut CCSUsrMsg_KillCam| { &mut m.second_target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_KillCam>(
                "CCSUsrMsg_KillCam",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_KillCam {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_KillCam> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_KillCam::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_KillCam {
    fn clear(&mut self) {
        self.obs_mode = ::std::option::Option::None;
        self.first_target = ::std::option::Option::None;
        self.second_target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_KillCam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_KillCam {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_DesiredTimescale {
    // message fields
    desired_timescale: ::std::option::Option<f32>,
    duration_realtime_sec: ::std::option::Option<f32>,
    interpolator_type: ::std::option::Option<i32>,
    start_blend_time: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DesiredTimescale {
    fn default() -> &'a CCSUsrMsg_DesiredTimescale {
        <CCSUsrMsg_DesiredTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DesiredTimescale {
    pub fn new() -> CCSUsrMsg_DesiredTimescale {
        ::std::default::Default::default()
    }

    // optional float desired_timescale = 1;


    pub fn get_desired_timescale(&self) -> f32 {
        self.desired_timescale.unwrap_or(0.)
    }
    pub fn clear_desired_timescale(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
    }

    pub fn has_desired_timescale(&self) -> bool {
        self.desired_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_timescale(&mut self, v: f32) {
        self.desired_timescale = ::std::option::Option::Some(v);
    }

    // optional float duration_realtime_sec = 2;


    pub fn get_duration_realtime_sec(&self) -> f32 {
        self.duration_realtime_sec.unwrap_or(0.)
    }
    pub fn clear_duration_realtime_sec(&mut self) {
        self.duration_realtime_sec = ::std::option::Option::None;
    }

    pub fn has_duration_realtime_sec(&self) -> bool {
        self.duration_realtime_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_realtime_sec(&mut self, v: f32) {
        self.duration_realtime_sec = ::std::option::Option::Some(v);
    }

    // optional int32 interpolator_type = 3;


    pub fn get_interpolator_type(&self) -> i32 {
        self.interpolator_type.unwrap_or(0)
    }
    pub fn clear_interpolator_type(&mut self) {
        self.interpolator_type = ::std::option::Option::None;
    }

    pub fn has_interpolator_type(&self) -> bool {
        self.interpolator_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interpolator_type(&mut self, v: i32) {
        self.interpolator_type = ::std::option::Option::Some(v);
    }

    // optional float start_blend_time = 4;


    pub fn get_start_blend_time(&self) -> f32 {
        self.start_blend_time.unwrap_or(0.)
    }
    pub fn clear_start_blend_time(&mut self) {
        self.start_blend_time = ::std::option::Option::None;
    }

    pub fn has_start_blend_time(&self) -> bool {
        self.start_blend_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_blend_time(&mut self, v: f32) {
        self.start_blend_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_DesiredTimescale {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.desired_timescale = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.duration_realtime_sec = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.interpolator_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.start_blend_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.desired_timescale {
            my_size += 5;
        }
        if let Some(v) = self.duration_realtime_sec {
            my_size += 5;
        }
        if let Some(v) = self.interpolator_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.start_blend_time {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.desired_timescale {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.duration_realtime_sec {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.interpolator_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.start_blend_time {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_DesiredTimescale {
        CCSUsrMsg_DesiredTimescale::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "desired_timescale",
                |m: &CCSUsrMsg_DesiredTimescale| { &m.desired_timescale },
                |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.desired_timescale },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "duration_realtime_sec",
                |m: &CCSUsrMsg_DesiredTimescale| { &m.duration_realtime_sec },
                |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.duration_realtime_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "interpolator_type",
                |m: &CCSUsrMsg_DesiredTimescale| { &m.interpolator_type },
                |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.interpolator_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "start_blend_time",
                |m: &CCSUsrMsg_DesiredTimescale| { &m.start_blend_time },
                |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.start_blend_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_DesiredTimescale>(
                "CCSUsrMsg_DesiredTimescale",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_DesiredTimescale {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_DesiredTimescale> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_DesiredTimescale::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_DesiredTimescale {
    fn clear(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
        self.duration_realtime_sec = ::std::option::Option::None;
        self.interpolator_type = ::std::option::Option::None;
        self.start_blend_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_DesiredTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DesiredTimescale {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CurrentTimescale {
    // message fields
    cur_timescale: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CurrentTimescale {
    fn default() -> &'a CCSUsrMsg_CurrentTimescale {
        <CCSUsrMsg_CurrentTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CurrentTimescale {
    pub fn new() -> CCSUsrMsg_CurrentTimescale {
        ::std::default::Default::default()
    }

    // optional float cur_timescale = 1;


    pub fn get_cur_timescale(&self) -> f32 {
        self.cur_timescale.unwrap_or(0.)
    }
    pub fn clear_cur_timescale(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
    }

    pub fn has_cur_timescale(&self) -> bool {
        self.cur_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_timescale(&mut self, v: f32) {
        self.cur_timescale = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_CurrentTimescale {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cur_timescale = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.cur_timescale {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.cur_timescale {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CurrentTimescale {
        CCSUsrMsg_CurrentTimescale::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cur_timescale",
                |m: &CCSUsrMsg_CurrentTimescale| { &m.cur_timescale },
                |m: &mut CCSUsrMsg_CurrentTimescale| { &mut m.cur_timescale },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_CurrentTimescale>(
                "CCSUsrMsg_CurrentTimescale",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_CurrentTimescale {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_CurrentTimescale> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_CurrentTimescale::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CurrentTimescale {
    fn clear(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CurrentTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CurrentTimescale {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_AchievementEvent {
    // message fields
    achievement: ::std::option::Option<i32>,
    count: ::std::option::Option<i32>,
    user_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AchievementEvent {
    fn default() -> &'a CCSUsrMsg_AchievementEvent {
        <CCSUsrMsg_AchievementEvent as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AchievementEvent {
    pub fn new() -> CCSUsrMsg_AchievementEvent {
        ::std::default::Default::default()
    }

    // optional int32 achievement = 1;


    pub fn get_achievement(&self) -> i32 {
        self.achievement.unwrap_or(0)
    }
    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: i32) {
        self.achievement = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 user_id = 3;


    pub fn get_user_id(&self) -> i32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: i32) {
        self.user_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_AchievementEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.achievement = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.achievement {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.achievement {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.user_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_AchievementEvent {
        CCSUsrMsg_AchievementEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "achievement",
                |m: &CCSUsrMsg_AchievementEvent| { &m.achievement },
                |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.achievement },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &CCSUsrMsg_AchievementEvent| { &m.count },
                |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "user_id",
                |m: &CCSUsrMsg_AchievementEvent| { &m.user_id },
                |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.user_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_AchievementEvent>(
                "CCSUsrMsg_AchievementEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_AchievementEvent {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_AchievementEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_AchievementEvent::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_AchievementEvent {
    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_AchievementEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AchievementEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_MatchEndConditions {
    // message fields
    fraglimit: ::std::option::Option<i32>,
    mp_maxrounds: ::std::option::Option<i32>,
    mp_winlimit: ::std::option::Option<i32>,
    mp_timelimit: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MatchEndConditions {
    fn default() -> &'a CCSUsrMsg_MatchEndConditions {
        <CCSUsrMsg_MatchEndConditions as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MatchEndConditions {
    pub fn new() -> CCSUsrMsg_MatchEndConditions {
        ::std::default::Default::default()
    }

    // optional int32 fraglimit = 1;


    pub fn get_fraglimit(&self) -> i32 {
        self.fraglimit.unwrap_or(0)
    }
    pub fn clear_fraglimit(&mut self) {
        self.fraglimit = ::std::option::Option::None;
    }

    pub fn has_fraglimit(&self) -> bool {
        self.fraglimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fraglimit(&mut self, v: i32) {
        self.fraglimit = ::std::option::Option::Some(v);
    }

    // optional int32 mp_maxrounds = 2;


    pub fn get_mp_maxrounds(&self) -> i32 {
        self.mp_maxrounds.unwrap_or(0)
    }
    pub fn clear_mp_maxrounds(&mut self) {
        self.mp_maxrounds = ::std::option::Option::None;
    }

    pub fn has_mp_maxrounds(&self) -> bool {
        self.mp_maxrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_maxrounds(&mut self, v: i32) {
        self.mp_maxrounds = ::std::option::Option::Some(v);
    }

    // optional int32 mp_winlimit = 3;


    pub fn get_mp_winlimit(&self) -> i32 {
        self.mp_winlimit.unwrap_or(0)
    }
    pub fn clear_mp_winlimit(&mut self) {
        self.mp_winlimit = ::std::option::Option::None;
    }

    pub fn has_mp_winlimit(&self) -> bool {
        self.mp_winlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_winlimit(&mut self, v: i32) {
        self.mp_winlimit = ::std::option::Option::Some(v);
    }

    // optional int32 mp_timelimit = 4;


    pub fn get_mp_timelimit(&self) -> i32 {
        self.mp_timelimit.unwrap_or(0)
    }
    pub fn clear_mp_timelimit(&mut self) {
        self.mp_timelimit = ::std::option::Option::None;
    }

    pub fn has_mp_timelimit(&self) -> bool {
        self.mp_timelimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_timelimit(&mut self, v: i32) {
        self.mp_timelimit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_MatchEndConditions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fraglimit = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mp_maxrounds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mp_winlimit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mp_timelimit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fraglimit {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mp_maxrounds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mp_winlimit {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mp_timelimit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fraglimit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mp_maxrounds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.mp_winlimit {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.mp_timelimit {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_MatchEndConditions {
        CCSUsrMsg_MatchEndConditions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fraglimit",
                |m: &CCSUsrMsg_MatchEndConditions| { &m.fraglimit },
                |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.fraglimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mp_maxrounds",
                |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_maxrounds },
                |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_maxrounds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mp_winlimit",
                |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_winlimit },
                |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_winlimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mp_timelimit",
                |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_timelimit },
                |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_timelimit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_MatchEndConditions>(
                "CCSUsrMsg_MatchEndConditions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_MatchEndConditions {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_MatchEndConditions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_MatchEndConditions::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_MatchEndConditions {
    fn clear(&mut self) {
        self.fraglimit = ::std::option::Option::None;
        self.mp_maxrounds = ::std::option::Option::None;
        self.mp_winlimit = ::std::option::Option::None;
        self.mp_timelimit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_MatchEndConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MatchEndConditions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_PlayerStatsUpdate {
    // message fields
    version: ::std::option::Option<i32>,
    pub stats: ::protobuf::RepeatedField<CCSUsrMsg_PlayerStatsUpdate_Stat>,
    user_id: ::std::option::Option<i32>,
    crc: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerStatsUpdate {
    fn default() -> &'a CCSUsrMsg_PlayerStatsUpdate {
        <CCSUsrMsg_PlayerStatsUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerStatsUpdate {
    pub fn new() -> CCSUsrMsg_PlayerStatsUpdate {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // repeated .CCSUsrMsg_PlayerStatsUpdate.Stat stats = 4;


    pub fn get_stats(&self) -> &[CCSUsrMsg_PlayerStatsUpdate_Stat] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_PlayerStatsUpdate_Stat>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_PlayerStatsUpdate_Stat> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_PlayerStatsUpdate_Stat> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    // optional int32 user_id = 5;


    pub fn get_user_id(&self) -> i32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: i32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    // optional int32 crc = 6;


    pub fn get_crc(&self) -> i32 {
        self.crc.unwrap_or(0)
    }
    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: i32) {
        self.crc = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_PlayerStatsUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.crc = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        for v in &self.stats {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.user_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.crc {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_PlayerStatsUpdate {
        CCSUsrMsg_PlayerStatsUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.version },
                |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_PlayerStatsUpdate_Stat>>(
                "stats",
                |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.stats },
                |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "user_id",
                |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.user_id },
                |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.user_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "crc",
                |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.crc },
                |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.crc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_PlayerStatsUpdate>(
                "CCSUsrMsg_PlayerStatsUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerStatsUpdate {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_PlayerStatsUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_PlayerStatsUpdate::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_PlayerStatsUpdate {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.stats.clear();
        self.user_id = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_PlayerStatsUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PlayerStatsUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_PlayerStatsUpdate_Stat {
    // message fields
    idx: ::std::option::Option<i32>,
    delta: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn default() -> &'a CCSUsrMsg_PlayerStatsUpdate_Stat {
        <CCSUsrMsg_PlayerStatsUpdate_Stat as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerStatsUpdate_Stat {
    pub fn new() -> CCSUsrMsg_PlayerStatsUpdate_Stat {
        ::std::default::Default::default()
    }

    // optional int32 idx = 1;


    pub fn get_idx(&self) -> i32 {
        self.idx.unwrap_or(0)
    }
    pub fn clear_idx(&mut self) {
        self.idx = ::std::option::Option::None;
    }

    pub fn has_idx(&self) -> bool {
        self.idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idx(&mut self, v: i32) {
        self.idx = ::std::option::Option::Some(v);
    }

    // optional int32 delta = 2;


    pub fn get_delta(&self) -> i32 {
        self.delta.unwrap_or(0)
    }
    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: i32) {
        self.delta = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.delta = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.delta {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.delta {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_PlayerStatsUpdate_Stat {
        CCSUsrMsg_PlayerStatsUpdate_Stat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "idx",
                |m: &CCSUsrMsg_PlayerStatsUpdate_Stat| { &m.idx },
                |m: &mut CCSUsrMsg_PlayerStatsUpdate_Stat| { &mut m.idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "delta",
                |m: &CCSUsrMsg_PlayerStatsUpdate_Stat| { &m.delta },
                |m: &mut CCSUsrMsg_PlayerStatsUpdate_Stat| { &mut m.delta },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_PlayerStatsUpdate_Stat>(
                "CCSUsrMsg_PlayerStatsUpdate.Stat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerStatsUpdate_Stat {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_PlayerStatsUpdate_Stat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_PlayerStatsUpdate_Stat::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn clear(&mut self) {
        self.idx = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PlayerStatsUpdate_Stat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_DisplayInventory {
    // message fields
    display: ::std::option::Option<bool>,
    user_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DisplayInventory {
    fn default() -> &'a CCSUsrMsg_DisplayInventory {
        <CCSUsrMsg_DisplayInventory as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DisplayInventory {
    pub fn new() -> CCSUsrMsg_DisplayInventory {
        ::std::default::Default::default()
    }

    // optional bool display = 1;


    pub fn get_display(&self) -> bool {
        self.display.unwrap_or(false)
    }
    pub fn clear_display(&mut self) {
        self.display = ::std::option::Option::None;
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: bool) {
        self.display = ::std::option::Option::Some(v);
    }

    // optional int32 user_id = 2;


    pub fn get_user_id(&self) -> i32 {
        self.user_id.unwrap_or(0)
    }
    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: i32) {
        self.user_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_DisplayInventory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.display = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.display {
            my_size += 2;
        }
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.display {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.user_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_DisplayInventory {
        CCSUsrMsg_DisplayInventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "display",
                |m: &CCSUsrMsg_DisplayInventory| { &m.display },
                |m: &mut CCSUsrMsg_DisplayInventory| { &mut m.display },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "user_id",
                |m: &CCSUsrMsg_DisplayInventory| { &m.user_id },
                |m: &mut CCSUsrMsg_DisplayInventory| { &mut m.user_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_DisplayInventory>(
                "CCSUsrMsg_DisplayInventory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_DisplayInventory {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_DisplayInventory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_DisplayInventory::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_DisplayInventory {
    fn clear(&mut self) {
        self.display = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_DisplayInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DisplayInventory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_QuestProgress {
    // message fields
    quest_id: ::std::option::Option<u32>,
    normal_points: ::std::option::Option<u32>,
    bonus_points: ::std::option::Option<u32>,
    is_event_quest: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_QuestProgress {
    fn default() -> &'a CCSUsrMsg_QuestProgress {
        <CCSUsrMsg_QuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_QuestProgress {
    pub fn new() -> CCSUsrMsg_QuestProgress {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;


    pub fn get_quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 normal_points = 2;


    pub fn get_normal_points(&self) -> u32 {
        self.normal_points.unwrap_or(0)
    }
    pub fn clear_normal_points(&mut self) {
        self.normal_points = ::std::option::Option::None;
    }

    pub fn has_normal_points(&self) -> bool {
        self.normal_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_points(&mut self, v: u32) {
        self.normal_points = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_points = 3;


    pub fn get_bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }
    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }

    // optional bool is_event_quest = 4;


    pub fn get_is_event_quest(&self) -> bool {
        self.is_event_quest.unwrap_or(false)
    }
    pub fn clear_is_event_quest(&mut self) {
        self.is_event_quest = ::std::option::Option::None;
    }

    pub fn has_is_event_quest(&self) -> bool {
        self.is_event_quest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_quest(&mut self, v: bool) {
        self.is_event_quest = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_QuestProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.normal_points = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_points = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_event_quest = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.normal_points {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_event_quest {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.normal_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_event_quest {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_QuestProgress {
        CCSUsrMsg_QuestProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quest_id",
                |m: &CCSUsrMsg_QuestProgress| { &m.quest_id },
                |m: &mut CCSUsrMsg_QuestProgress| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "normal_points",
                |m: &CCSUsrMsg_QuestProgress| { &m.normal_points },
                |m: &mut CCSUsrMsg_QuestProgress| { &mut m.normal_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bonus_points",
                |m: &CCSUsrMsg_QuestProgress| { &m.bonus_points },
                |m: &mut CCSUsrMsg_QuestProgress| { &mut m.bonus_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_event_quest",
                |m: &CCSUsrMsg_QuestProgress| { &m.is_event_quest },
                |m: &mut CCSUsrMsg_QuestProgress| { &mut m.is_event_quest },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_QuestProgress>(
                "CCSUsrMsg_QuestProgress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_QuestProgress {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_QuestProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_QuestProgress::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_QuestProgress {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.normal_points = ::std::option::Option::None;
        self.bonus_points = ::std::option::Option::None;
        self.is_event_quest = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_QuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_QuestProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ScoreLeaderboardData {
    // message fields
    pub data: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::ScoreLeaderboardData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ScoreLeaderboardData {
    fn default() -> &'a CCSUsrMsg_ScoreLeaderboardData {
        <CCSUsrMsg_ScoreLeaderboardData as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ScoreLeaderboardData {
    pub fn new() -> CCSUsrMsg_ScoreLeaderboardData {
        ::std::default::Default::default()
    }

    // optional .ScoreLeaderboardData data = 1;


    pub fn get_data(&self) -> &super::cstrike15_gcmessages::ScoreLeaderboardData {
        self.data.as_ref().unwrap_or_else(|| <super::cstrike15_gcmessages::ScoreLeaderboardData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::cstrike15_gcmessages::ScoreLeaderboardData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::cstrike15_gcmessages::ScoreLeaderboardData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::cstrike15_gcmessages::ScoreLeaderboardData {
        self.data.take().unwrap_or_else(|| super::cstrike15_gcmessages::ScoreLeaderboardData::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ScoreLeaderboardData {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ScoreLeaderboardData {
        CCSUsrMsg_ScoreLeaderboardData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::ScoreLeaderboardData>>(
                "data",
                |m: &CCSUsrMsg_ScoreLeaderboardData| { &m.data },
                |m: &mut CCSUsrMsg_ScoreLeaderboardData| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ScoreLeaderboardData>(
                "CCSUsrMsg_ScoreLeaderboardData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ScoreLeaderboardData {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ScoreLeaderboardData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ScoreLeaderboardData::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ScoreLeaderboardData {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ScoreLeaderboardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ScoreLeaderboardData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_PlayerDecalDigitalSignature {
    // message fields
    pub data: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::PlayerDecalDigitalSignature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerDecalDigitalSignature {
    fn default() -> &'a CCSUsrMsg_PlayerDecalDigitalSignature {
        <CCSUsrMsg_PlayerDecalDigitalSignature as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerDecalDigitalSignature {
    pub fn new() -> CCSUsrMsg_PlayerDecalDigitalSignature {
        ::std::default::Default::default()
    }

    // optional .PlayerDecalDigitalSignature data = 1;


    pub fn get_data(&self) -> &super::cstrike15_gcmessages::PlayerDecalDigitalSignature {
        self.data.as_ref().unwrap_or_else(|| <super::cstrike15_gcmessages::PlayerDecalDigitalSignature as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::cstrike15_gcmessages::PlayerDecalDigitalSignature) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::cstrike15_gcmessages::PlayerDecalDigitalSignature {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::cstrike15_gcmessages::PlayerDecalDigitalSignature {
        self.data.take().unwrap_or_else(|| super::cstrike15_gcmessages::PlayerDecalDigitalSignature::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_PlayerDecalDigitalSignature {
        CCSUsrMsg_PlayerDecalDigitalSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::PlayerDecalDigitalSignature>>(
                "data",
                |m: &CCSUsrMsg_PlayerDecalDigitalSignature| { &m.data },
                |m: &mut CCSUsrMsg_PlayerDecalDigitalSignature| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_PlayerDecalDigitalSignature>(
                "CCSUsrMsg_PlayerDecalDigitalSignature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerDecalDigitalSignature {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_PlayerDecalDigitalSignature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_PlayerDecalDigitalSignature::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_XRankGet {
    // message fields
    mode_idx: ::std::option::Option<i32>,
    controller: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XRankGet {
    fn default() -> &'a CCSUsrMsg_XRankGet {
        <CCSUsrMsg_XRankGet as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XRankGet {
    pub fn new() -> CCSUsrMsg_XRankGet {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;


    pub fn get_mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }
    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;


    pub fn get_controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }
    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_XRankGet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.controller = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_XRankGet {
        CCSUsrMsg_XRankGet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mode_idx",
                |m: &CCSUsrMsg_XRankGet| { &m.mode_idx },
                |m: &mut CCSUsrMsg_XRankGet| { &mut m.mode_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "controller",
                |m: &CCSUsrMsg_XRankGet| { &m.controller },
                |m: &mut CCSUsrMsg_XRankGet| { &mut m.controller },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_XRankGet>(
                "CCSUsrMsg_XRankGet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_XRankGet {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_XRankGet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_XRankGet::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_XRankGet {
    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_XRankGet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XRankGet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_XRankUpd {
    // message fields
    mode_idx: ::std::option::Option<i32>,
    controller: ::std::option::Option<i32>,
    ranking: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XRankUpd {
    fn default() -> &'a CCSUsrMsg_XRankUpd {
        <CCSUsrMsg_XRankUpd as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XRankUpd {
    pub fn new() -> CCSUsrMsg_XRankUpd {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;


    pub fn get_mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }
    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;


    pub fn get_controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }
    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }

    // optional int32 ranking = 3;


    pub fn get_ranking(&self) -> i32 {
        self.ranking.unwrap_or(0)
    }
    pub fn clear_ranking(&mut self) {
        self.ranking = ::std::option::Option::None;
    }

    pub fn has_ranking(&self) -> bool {
        self.ranking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranking(&mut self, v: i32) {
        self.ranking = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_XRankUpd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode_idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.controller = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ranking = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ranking {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ranking {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_XRankUpd {
        CCSUsrMsg_XRankUpd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mode_idx",
                |m: &CCSUsrMsg_XRankUpd| { &m.mode_idx },
                |m: &mut CCSUsrMsg_XRankUpd| { &mut m.mode_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "controller",
                |m: &CCSUsrMsg_XRankUpd| { &m.controller },
                |m: &mut CCSUsrMsg_XRankUpd| { &mut m.controller },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ranking",
                |m: &CCSUsrMsg_XRankUpd| { &m.ranking },
                |m: &mut CCSUsrMsg_XRankUpd| { &mut m.ranking },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_XRankUpd>(
                "CCSUsrMsg_XRankUpd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_XRankUpd {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_XRankUpd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_XRankUpd::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_XRankUpd {
    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.ranking = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_XRankUpd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XRankUpd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CallVoteFailed {
    // message fields
    reason: ::std::option::Option<i32>,
    time: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CallVoteFailed {
    fn default() -> &'a CCSUsrMsg_CallVoteFailed {
        <CCSUsrMsg_CallVoteFailed as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CallVoteFailed {
    pub fn new() -> CCSUsrMsg_CallVoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 reason = 1;


    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional int32 time = 2;


    pub fn get_time(&self) -> i32 {
        self.time.unwrap_or(0)
    }
    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_CallVoteFailed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CallVoteFailed {
        CCSUsrMsg_CallVoteFailed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "reason",
                |m: &CCSUsrMsg_CallVoteFailed| { &m.reason },
                |m: &mut CCSUsrMsg_CallVoteFailed| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "time",
                |m: &CCSUsrMsg_CallVoteFailed| { &m.time },
                |m: &mut CCSUsrMsg_CallVoteFailed| { &mut m.time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_CallVoteFailed>(
                "CCSUsrMsg_CallVoteFailed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_CallVoteFailed {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_CallVoteFailed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_CallVoteFailed::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CallVoteFailed {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CallVoteFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CallVoteFailed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoteStart {
    // message fields
    team: ::std::option::Option<i32>,
    ent_idx: ::std::option::Option<i32>,
    vote_type: ::std::option::Option<i32>,
    disp_str: ::protobuf::SingularField<::std::string::String>,
    details_str: ::protobuf::SingularField<::std::string::String>,
    other_team_str: ::protobuf::SingularField<::std::string::String>,
    is_yes_no_vote: ::std::option::Option<bool>,
    entidx_target: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteStart {
    fn default() -> &'a CCSUsrMsg_VoteStart {
        <CCSUsrMsg_VoteStart as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteStart {
    pub fn new() -> CCSUsrMsg_VoteStart {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;


    pub fn get_team(&self) -> i32 {
        self.team.unwrap_or(0)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 ent_idx = 2;


    pub fn get_ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }
    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 3;


    pub fn get_vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }
    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 4;


    pub fn get_disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_disp_str(&mut self) {
        self.disp_str.clear();
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::std::string::String) {
        self.disp_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::std::string::String {
        if self.disp_str.is_none() {
            self.disp_str.set_default();
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::std::string::String {
        self.disp_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string details_str = 5;


    pub fn get_details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_details_str(&mut self) {
        self.details_str.clear();
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::std::string::String) {
        self.details_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::std::string::String {
        if self.details_str.is_none() {
            self.details_str.set_default();
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::std::string::String {
        self.details_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string other_team_str = 6;


    pub fn get_other_team_str(&self) -> &str {
        match self.other_team_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_other_team_str(&mut self) {
        self.other_team_str.clear();
    }

    pub fn has_other_team_str(&self) -> bool {
        self.other_team_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_team_str(&mut self, v: ::std::string::String) {
        self.other_team_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_team_str(&mut self) -> &mut ::std::string::String {
        if self.other_team_str.is_none() {
            self.other_team_str.set_default();
        }
        self.other_team_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_team_str(&mut self) -> ::std::string::String {
        self.other_team_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_yes_no_vote = 7;


    pub fn get_is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.unwrap_or(false)
    }
    pub fn clear_is_yes_no_vote(&mut self) {
        self.is_yes_no_vote = ::std::option::Option::None;
    }

    pub fn has_is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_yes_no_vote(&mut self, v: bool) {
        self.is_yes_no_vote = ::std::option::Option::Some(v);
    }

    // optional int32 entidx_target = 8;


    pub fn get_entidx_target(&self) -> i32 {
        self.entidx_target.unwrap_or(0)
    }
    pub fn clear_entidx_target(&mut self) {
        self.entidx_target = ::std::option::Option::None;
    }

    pub fn has_entidx_target(&self) -> bool {
        self.entidx_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx_target(&mut self, v: i32) {
        self.entidx_target = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteStart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ent_idx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vote_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.disp_str)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.details_str)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.other_team_str)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_yes_no_vote = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx_target = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.disp_str.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.details_str.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.other_team_str.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_yes_no_vote {
            my_size += 2;
        }
        if let Some(v) = self.entidx_target {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ent_idx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.disp_str.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.details_str.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.other_team_str.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.is_yes_no_vote {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.entidx_target {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoteStart {
        CCSUsrMsg_VoteStart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "team",
                |m: &CCSUsrMsg_VoteStart| { &m.team },
                |m: &mut CCSUsrMsg_VoteStart| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ent_idx",
                |m: &CCSUsrMsg_VoteStart| { &m.ent_idx },
                |m: &mut CCSUsrMsg_VoteStart| { &mut m.ent_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vote_type",
                |m: &CCSUsrMsg_VoteStart| { &m.vote_type },
                |m: &mut CCSUsrMsg_VoteStart| { &mut m.vote_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "disp_str",
                |m: &CCSUsrMsg_VoteStart| { &m.disp_str },
                |m: &mut CCSUsrMsg_VoteStart| { &mut m.disp_str },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "details_str",
                |m: &CCSUsrMsg_VoteStart| { &m.details_str },
                |m: &mut CCSUsrMsg_VoteStart| { &mut m.details_str },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "other_team_str",
                |m: &CCSUsrMsg_VoteStart| { &m.other_team_str },
                |m: &mut CCSUsrMsg_VoteStart| { &mut m.other_team_str },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_yes_no_vote",
                |m: &CCSUsrMsg_VoteStart| { &m.is_yes_no_vote },
                |m: &mut CCSUsrMsg_VoteStart| { &mut m.is_yes_no_vote },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entidx_target",
                |m: &CCSUsrMsg_VoteStart| { &m.entidx_target },
                |m: &mut CCSUsrMsg_VoteStart| { &mut m.entidx_target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_VoteStart>(
                "CCSUsrMsg_VoteStart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteStart {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_VoteStart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_VoteStart::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoteStart {
    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.ent_idx = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str.clear();
        self.details_str.clear();
        self.other_team_str.clear();
        self.is_yes_no_vote = ::std::option::Option::None;
        self.entidx_target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoteStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteStart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VotePass {
    // message fields
    team: ::std::option::Option<i32>,
    vote_type: ::std::option::Option<i32>,
    disp_str: ::protobuf::SingularField<::std::string::String>,
    details_str: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VotePass {
    fn default() -> &'a CCSUsrMsg_VotePass {
        <CCSUsrMsg_VotePass as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VotePass {
    pub fn new() -> CCSUsrMsg_VotePass {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;


    pub fn get_team(&self) -> i32 {
        self.team.unwrap_or(0)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 2;


    pub fn get_vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }
    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 3;


    pub fn get_disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_disp_str(&mut self) {
        self.disp_str.clear();
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::std::string::String) {
        self.disp_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::std::string::String {
        if self.disp_str.is_none() {
            self.disp_str.set_default();
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::std::string::String {
        self.disp_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string details_str = 4;


    pub fn get_details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_details_str(&mut self) {
        self.details_str.clear();
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::std::string::String) {
        self.details_str = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::std::string::String {
        if self.details_str.is_none() {
            self.details_str.set_default();
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::std::string::String {
        self.details_str.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_VotePass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vote_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.disp_str)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.details_str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.vote_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.disp_str.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.details_str.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.disp_str.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.details_str.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VotePass {
        CCSUsrMsg_VotePass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "team",
                |m: &CCSUsrMsg_VotePass| { &m.team },
                |m: &mut CCSUsrMsg_VotePass| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vote_type",
                |m: &CCSUsrMsg_VotePass| { &m.vote_type },
                |m: &mut CCSUsrMsg_VotePass| { &mut m.vote_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "disp_str",
                |m: &CCSUsrMsg_VotePass| { &m.disp_str },
                |m: &mut CCSUsrMsg_VotePass| { &mut m.disp_str },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "details_str",
                |m: &CCSUsrMsg_VotePass| { &m.details_str },
                |m: &mut CCSUsrMsg_VotePass| { &mut m.details_str },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_VotePass>(
                "CCSUsrMsg_VotePass",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_VotePass {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_VotePass> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_VotePass::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VotePass {
    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str.clear();
        self.details_str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VotePass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VotePass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoteFailed {
    // message fields
    team: ::std::option::Option<i32>,
    reason: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteFailed {
    fn default() -> &'a CCSUsrMsg_VoteFailed {
        <CCSUsrMsg_VoteFailed as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteFailed {
    pub fn new() -> CCSUsrMsg_VoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;


    pub fn get_team(&self) -> i32 {
        self.team.unwrap_or(0)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 2;


    pub fn get_reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteFailed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoteFailed {
        CCSUsrMsg_VoteFailed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "team",
                |m: &CCSUsrMsg_VoteFailed| { &m.team },
                |m: &mut CCSUsrMsg_VoteFailed| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "reason",
                |m: &CCSUsrMsg_VoteFailed| { &m.reason },
                |m: &mut CCSUsrMsg_VoteFailed| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_VoteFailed>(
                "CCSUsrMsg_VoteFailed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteFailed {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_VoteFailed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_VoteFailed::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoteFailed {
    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoteFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteFailed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_VoteSetup {
    // message fields
    pub potential_issues: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteSetup {
    fn default() -> &'a CCSUsrMsg_VoteSetup {
        <CCSUsrMsg_VoteSetup as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteSetup {
    pub fn new() -> CCSUsrMsg_VoteSetup {
        ::std::default::Default::default()
    }

    // repeated string potential_issues = 1;


    pub fn get_potential_issues(&self) -> &[::std::string::String] {
        &self.potential_issues
    }
    pub fn clear_potential_issues(&mut self) {
        self.potential_issues.clear();
    }

    // Param is passed by value, moved
    pub fn set_potential_issues(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.potential_issues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_potential_issues(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.potential_issues
    }

    // Take field
    pub fn take_potential_issues(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.potential_issues, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteSetup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.potential_issues)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.potential_issues {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.potential_issues {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_VoteSetup {
        CCSUsrMsg_VoteSetup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "potential_issues",
                |m: &CCSUsrMsg_VoteSetup| { &m.potential_issues },
                |m: &mut CCSUsrMsg_VoteSetup| { &mut m.potential_issues },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_VoteSetup>(
                "CCSUsrMsg_VoteSetup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteSetup {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_VoteSetup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_VoteSetup::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_VoteSetup {
    fn clear(&mut self) {
        self.potential_issues.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_VoteSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteSetup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SendLastKillerDamageToClient {
    // message fields
    num_hits_given: ::std::option::Option<i32>,
    damage_given: ::std::option::Option<i32>,
    num_hits_taken: ::std::option::Option<i32>,
    damage_taken: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendLastKillerDamageToClient {
    fn default() -> &'a CCSUsrMsg_SendLastKillerDamageToClient {
        <CCSUsrMsg_SendLastKillerDamageToClient as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendLastKillerDamageToClient {
    pub fn new() -> CCSUsrMsg_SendLastKillerDamageToClient {
        ::std::default::Default::default()
    }

    // optional int32 num_hits_given = 1;


    pub fn get_num_hits_given(&self) -> i32 {
        self.num_hits_given.unwrap_or(0)
    }
    pub fn clear_num_hits_given(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
    }

    pub fn has_num_hits_given(&self) -> bool {
        self.num_hits_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_given(&mut self, v: i32) {
        self.num_hits_given = ::std::option::Option::Some(v);
    }

    // optional int32 damage_given = 2;


    pub fn get_damage_given(&self) -> i32 {
        self.damage_given.unwrap_or(0)
    }
    pub fn clear_damage_given(&mut self) {
        self.damage_given = ::std::option::Option::None;
    }

    pub fn has_damage_given(&self) -> bool {
        self.damage_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_given(&mut self, v: i32) {
        self.damage_given = ::std::option::Option::Some(v);
    }

    // optional int32 num_hits_taken = 3;


    pub fn get_num_hits_taken(&self) -> i32 {
        self.num_hits_taken.unwrap_or(0)
    }
    pub fn clear_num_hits_taken(&mut self) {
        self.num_hits_taken = ::std::option::Option::None;
    }

    pub fn has_num_hits_taken(&self) -> bool {
        self.num_hits_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_taken(&mut self, v: i32) {
        self.num_hits_taken = ::std::option::Option::Some(v);
    }

    // optional int32 damage_taken = 4;


    pub fn get_damage_taken(&self) -> i32 {
        self.damage_taken.unwrap_or(0)
    }
    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: i32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendLastKillerDamageToClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_hits_given = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.damage_given = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_hits_taken = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.damage_taken = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.num_hits_given {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_given {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_hits_taken {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.num_hits_given {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_given {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.num_hits_taken {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SendLastKillerDamageToClient {
        CCSUsrMsg_SendLastKillerDamageToClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_hits_given",
                |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.num_hits_given },
                |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.num_hits_given },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "damage_given",
                |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.damage_given },
                |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.damage_given },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_hits_taken",
                |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.num_hits_taken },
                |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.num_hits_taken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "damage_taken",
                |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.damage_taken },
                |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.damage_taken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SendLastKillerDamageToClient>(
                "CCSUsrMsg_SendLastKillerDamageToClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SendLastKillerDamageToClient {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SendLastKillerDamageToClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SendLastKillerDamageToClient::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SendLastKillerDamageToClient {
    fn clear(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
        self.damage_given = ::std::option::Option::None;
        self.num_hits_taken = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SendLastKillerDamageToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendLastKillerDamageToClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ServerRankUpdate {
    // message fields
    pub rank_update: ::protobuf::RepeatedField<CCSUsrMsg_ServerRankUpdate_RankUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankUpdate {
    fn default() -> &'a CCSUsrMsg_ServerRankUpdate {
        <CCSUsrMsg_ServerRankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankUpdate {
    pub fn new() -> CCSUsrMsg_ServerRankUpdate {
        ::std::default::Default::default()
    }

    // repeated .CCSUsrMsg_ServerRankUpdate.RankUpdate rank_update = 1;


    pub fn get_rank_update(&self) -> &[CCSUsrMsg_ServerRankUpdate_RankUpdate] {
        &self.rank_update
    }
    pub fn clear_rank_update(&mut self) {
        self.rank_update.clear();
    }

    // Param is passed by value, moved
    pub fn set_rank_update(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_ServerRankUpdate_RankUpdate>) {
        self.rank_update = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rank_update(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_ServerRankUpdate_RankUpdate> {
        &mut self.rank_update
    }

    // Take field
    pub fn take_rank_update(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_ServerRankUpdate_RankUpdate> {
        ::std::mem::replace(&mut self.rank_update, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ServerRankUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.rank_update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rank_update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rank_update {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rank_update {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ServerRankUpdate {
        CCSUsrMsg_ServerRankUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_ServerRankUpdate_RankUpdate>>(
                "rank_update",
                |m: &CCSUsrMsg_ServerRankUpdate| { &m.rank_update },
                |m: &mut CCSUsrMsg_ServerRankUpdate| { &mut m.rank_update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ServerRankUpdate>(
                "CCSUsrMsg_ServerRankUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankUpdate {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ServerRankUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ServerRankUpdate::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ServerRankUpdate {
    fn clear(&mut self) {
        self.rank_update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ServerRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ServerRankUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ServerRankUpdate_RankUpdate {
    // message fields
    account_id: ::std::option::Option<i32>,
    rank_old: ::std::option::Option<i32>,
    rank_new: ::std::option::Option<i32>,
    num_wins: ::std::option::Option<i32>,
    rank_change: ::std::option::Option<f32>,
    rank_type_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn default() -> &'a CCSUsrMsg_ServerRankUpdate_RankUpdate {
        <CCSUsrMsg_ServerRankUpdate_RankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankUpdate_RankUpdate {
    pub fn new() -> CCSUsrMsg_ServerRankUpdate_RankUpdate {
        ::std::default::Default::default()
    }

    // optional int32 account_id = 1;


    pub fn get_account_id(&self) -> i32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: i32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 rank_old = 2;


    pub fn get_rank_old(&self) -> i32 {
        self.rank_old.unwrap_or(0)
    }
    pub fn clear_rank_old(&mut self) {
        self.rank_old = ::std::option::Option::None;
    }

    pub fn has_rank_old(&self) -> bool {
        self.rank_old.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_old(&mut self, v: i32) {
        self.rank_old = ::std::option::Option::Some(v);
    }

    // optional int32 rank_new = 3;


    pub fn get_rank_new(&self) -> i32 {
        self.rank_new.unwrap_or(0)
    }
    pub fn clear_rank_new(&mut self) {
        self.rank_new = ::std::option::Option::None;
    }

    pub fn has_rank_new(&self) -> bool {
        self.rank_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_new(&mut self, v: i32) {
        self.rank_new = ::std::option::Option::Some(v);
    }

    // optional int32 num_wins = 4;


    pub fn get_num_wins(&self) -> i32 {
        self.num_wins.unwrap_or(0)
    }
    pub fn clear_num_wins(&mut self) {
        self.num_wins = ::std::option::Option::None;
    }

    pub fn has_num_wins(&self) -> bool {
        self.num_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_wins(&mut self, v: i32) {
        self.num_wins = ::std::option::Option::Some(v);
    }

    // optional float rank_change = 5;


    pub fn get_rank_change(&self) -> f32 {
        self.rank_change.unwrap_or(0.)
    }
    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: f32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional int32 rank_type_id = 6;


    pub fn get_rank_type_id(&self) -> i32 {
        self.rank_type_id.unwrap_or(0)
    }
    pub fn clear_rank_type_id(&mut self) {
        self.rank_type_id = ::std::option::Option::None;
    }

    pub fn has_rank_type_id(&self) -> bool {
        self.rank_type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_type_id(&mut self, v: i32) {
        self.rank_type_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank_old = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank_new = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_wins = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rank_change = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank_type_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_old {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_new {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_wins {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank_change {
            my_size += 5;
        }
        if let Some(v) = self.rank_type_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rank_old {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rank_new {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.num_wins {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.rank_type_id {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ServerRankUpdate_RankUpdate {
        CCSUsrMsg_ServerRankUpdate_RankUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "account_id",
                |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.account_id },
                |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rank_old",
                |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.rank_old },
                |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.rank_old },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rank_new",
                |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.rank_new },
                |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.rank_new },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_wins",
                |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.num_wins },
                |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.num_wins },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "rank_change",
                |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.rank_change },
                |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.rank_change },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rank_type_id",
                |m: &CCSUsrMsg_ServerRankUpdate_RankUpdate| { &m.rank_type_id },
                |m: &mut CCSUsrMsg_ServerRankUpdate_RankUpdate| { &mut m.rank_type_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ServerRankUpdate_RankUpdate>(
                "CCSUsrMsg_ServerRankUpdate.RankUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankUpdate_RankUpdate {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ServerRankUpdate_RankUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ServerRankUpdate_RankUpdate::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rank_old = ::std::option::Option::None;
        self.rank_new = ::std::option::Option::None;
        self.num_wins = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.rank_type_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ServerRankUpdate_RankUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_XpUpdate {
    // message fields
    pub data: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XpUpdate {
    fn default() -> &'a CCSUsrMsg_XpUpdate {
        <CCSUsrMsg_XpUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XpUpdate {
    pub fn new() -> CCSUsrMsg_XpUpdate {
        ::std::default::Default::default()
    }

    // optional .CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded data = 1;


    pub fn get_data(&self) -> &super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        self.data.as_ref().unwrap_or_else(|| <super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        self.data.take().unwrap_or_else(|| super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_XpUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_XpUpdate {
        CCSUsrMsg_XpUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>>(
                "data",
                |m: &CCSUsrMsg_XpUpdate| { &m.data },
                |m: &mut CCSUsrMsg_XpUpdate| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_XpUpdate>(
                "CCSUsrMsg_XpUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_XpUpdate {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_XpUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_XpUpdate::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_XpUpdate {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_XpUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XpUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ItemPickup {
    // message fields
    item: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ItemPickup {
    fn default() -> &'a CCSUsrMsg_ItemPickup {
        <CCSUsrMsg_ItemPickup as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ItemPickup {
    pub fn new() -> CCSUsrMsg_ItemPickup {
        ::std::default::Default::default()
    }

    // optional string item = 1;


    pub fn get_item(&self) -> &str {
        match self.item.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::std::string::String) {
        self.item = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut ::std::string::String {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> ::std::string::String {
        self.item.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ItemPickup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ItemPickup {
        CCSUsrMsg_ItemPickup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item",
                |m: &CCSUsrMsg_ItemPickup| { &m.item },
                |m: &mut CCSUsrMsg_ItemPickup| { &mut m.item },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ItemPickup>(
                "CCSUsrMsg_ItemPickup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ItemPickup {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ItemPickup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ItemPickup::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ItemPickup {
    fn clear(&mut self) {
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ItemPickup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ItemPickup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ShowMenu {
    // message fields
    bits_valid_slots: ::std::option::Option<i32>,
    display_time: ::std::option::Option<i32>,
    menu_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ShowMenu {
    fn default() -> &'a CCSUsrMsg_ShowMenu {
        <CCSUsrMsg_ShowMenu as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ShowMenu {
    pub fn new() -> CCSUsrMsg_ShowMenu {
        ::std::default::Default::default()
    }

    // optional int32 bits_valid_slots = 1;


    pub fn get_bits_valid_slots(&self) -> i32 {
        self.bits_valid_slots.unwrap_or(0)
    }
    pub fn clear_bits_valid_slots(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
    }

    pub fn has_bits_valid_slots(&self) -> bool {
        self.bits_valid_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits_valid_slots(&mut self, v: i32) {
        self.bits_valid_slots = ::std::option::Option::Some(v);
    }

    // optional int32 display_time = 2;


    pub fn get_display_time(&self) -> i32 {
        self.display_time.unwrap_or(0)
    }
    pub fn clear_display_time(&mut self) {
        self.display_time = ::std::option::Option::None;
    }

    pub fn has_display_time(&self) -> bool {
        self.display_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_time(&mut self, v: i32) {
        self.display_time = ::std::option::Option::Some(v);
    }

    // optional string menu_string = 3;


    pub fn get_menu_string(&self) -> &str {
        match self.menu_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_menu_string(&mut self) {
        self.menu_string.clear();
    }

    pub fn has_menu_string(&self) -> bool {
        self.menu_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_string(&mut self, v: ::std::string::String) {
        self.menu_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_string(&mut self) -> &mut ::std::string::String {
        if self.menu_string.is_none() {
            self.menu_string.set_default();
        }
        self.menu_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_string(&mut self) -> ::std::string::String {
        self.menu_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ShowMenu {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bits_valid_slots = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.display_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.menu_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bits_valid_slots {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.display_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.menu_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bits_valid_slots {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.display_time {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.menu_string.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ShowMenu {
        CCSUsrMsg_ShowMenu::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bits_valid_slots",
                |m: &CCSUsrMsg_ShowMenu| { &m.bits_valid_slots },
                |m: &mut CCSUsrMsg_ShowMenu| { &mut m.bits_valid_slots },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "display_time",
                |m: &CCSUsrMsg_ShowMenu| { &m.display_time },
                |m: &mut CCSUsrMsg_ShowMenu| { &mut m.display_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "menu_string",
                |m: &CCSUsrMsg_ShowMenu| { &m.menu_string },
                |m: &mut CCSUsrMsg_ShowMenu| { &mut m.menu_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ShowMenu>(
                "CCSUsrMsg_ShowMenu",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ShowMenu {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ShowMenu> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ShowMenu::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ShowMenu {
    fn clear(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
        self.display_time = ::std::option::Option::None;
        self.menu_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ShowMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ShowMenu {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_BarTime {
    // message fields
    time: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_BarTime {
    fn default() -> &'a CCSUsrMsg_BarTime {
        <CCSUsrMsg_BarTime as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_BarTime {
    pub fn new() -> CCSUsrMsg_BarTime {
        ::std::default::Default::default()
    }

    // optional string time = 1;


    pub fn get_time(&self) -> &str {
        match self.time.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::std::string::String) {
        self.time = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::std::string::String {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::std::string::String {
        self.time.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_BarTime {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_BarTime {
        CCSUsrMsg_BarTime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "time",
                |m: &CCSUsrMsg_BarTime| { &m.time },
                |m: &mut CCSUsrMsg_BarTime| { &mut m.time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_BarTime>(
                "CCSUsrMsg_BarTime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_BarTime {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_BarTime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_BarTime::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_BarTime {
    fn clear(&mut self) {
        self.time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_BarTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_BarTime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_AmmoDenied {
    // message fields
    ammoIdx: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AmmoDenied {
    fn default() -> &'a CCSUsrMsg_AmmoDenied {
        <CCSUsrMsg_AmmoDenied as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AmmoDenied {
    pub fn new() -> CCSUsrMsg_AmmoDenied {
        ::std::default::Default::default()
    }

    // optional int32 ammoIdx = 1;


    pub fn get_ammoIdx(&self) -> i32 {
        self.ammoIdx.unwrap_or(0)
    }
    pub fn clear_ammoIdx(&mut self) {
        self.ammoIdx = ::std::option::Option::None;
    }

    pub fn has_ammoIdx(&self) -> bool {
        self.ammoIdx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammoIdx(&mut self, v: i32) {
        self.ammoIdx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_AmmoDenied {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ammoIdx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ammoIdx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ammoIdx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_AmmoDenied {
        CCSUsrMsg_AmmoDenied::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ammoIdx",
                |m: &CCSUsrMsg_AmmoDenied| { &m.ammoIdx },
                |m: &mut CCSUsrMsg_AmmoDenied| { &mut m.ammoIdx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_AmmoDenied>(
                "CCSUsrMsg_AmmoDenied",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_AmmoDenied {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_AmmoDenied> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_AmmoDenied::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_AmmoDenied {
    fn clear(&mut self) {
        self.ammoIdx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_AmmoDenied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AmmoDenied {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_MarkAchievement {
    // message fields
    achievement: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MarkAchievement {
    fn default() -> &'a CCSUsrMsg_MarkAchievement {
        <CCSUsrMsg_MarkAchievement as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MarkAchievement {
    pub fn new() -> CCSUsrMsg_MarkAchievement {
        ::std::default::Default::default()
    }

    // optional string achievement = 1;


    pub fn get_achievement(&self) -> &str {
        match self.achievement.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_achievement(&mut self) {
        self.achievement.clear();
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: ::std::string::String) {
        self.achievement = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement(&mut self) -> &mut ::std::string::String {
        if self.achievement.is_none() {
            self.achievement.set_default();
        }
        self.achievement.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievement(&mut self) -> ::std::string::String {
        self.achievement.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_MarkAchievement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.achievement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.achievement.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.achievement.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_MarkAchievement {
        CCSUsrMsg_MarkAchievement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "achievement",
                |m: &CCSUsrMsg_MarkAchievement| { &m.achievement },
                |m: &mut CCSUsrMsg_MarkAchievement| { &mut m.achievement },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_MarkAchievement>(
                "CCSUsrMsg_MarkAchievement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_MarkAchievement {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_MarkAchievement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_MarkAchievement::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_MarkAchievement {
    fn clear(&mut self) {
        self.achievement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_MarkAchievement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MarkAchievement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_MatchStatsUpdate {
    // message fields
    update: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MatchStatsUpdate {
    fn default() -> &'a CCSUsrMsg_MatchStatsUpdate {
        <CCSUsrMsg_MatchStatsUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MatchStatsUpdate {
    pub fn new() -> CCSUsrMsg_MatchStatsUpdate {
        ::std::default::Default::default()
    }

    // optional string update = 1;


    pub fn get_update(&self) -> &str {
        match self.update.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: ::std::string::String) {
        self.update = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut ::std::string::String {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> ::std::string::String {
        self.update.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_MatchStatsUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.update.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.update.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_MatchStatsUpdate {
        CCSUsrMsg_MatchStatsUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "update",
                |m: &CCSUsrMsg_MatchStatsUpdate| { &m.update },
                |m: &mut CCSUsrMsg_MatchStatsUpdate| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_MatchStatsUpdate>(
                "CCSUsrMsg_MatchStatsUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_MatchStatsUpdate {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_MatchStatsUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_MatchStatsUpdate::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_MatchStatsUpdate {
    fn clear(&mut self) {
        self.update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_MatchStatsUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MatchStatsUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ItemDrop {
    // message fields
    itemid: ::std::option::Option<i64>,
    death: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ItemDrop {
    fn default() -> &'a CCSUsrMsg_ItemDrop {
        <CCSUsrMsg_ItemDrop as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ItemDrop {
    pub fn new() -> CCSUsrMsg_ItemDrop {
        ::std::default::Default::default()
    }

    // optional int64 itemid = 1;


    pub fn get_itemid(&self) -> i64 {
        self.itemid.unwrap_or(0)
    }
    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: i64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional bool death = 2;


    pub fn get_death(&self) -> bool {
        self.death.unwrap_or(false)
    }
    pub fn clear_death(&mut self) {
        self.death = ::std::option::Option::None;
    }

    pub fn has_death(&self) -> bool {
        self.death.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death(&mut self, v: bool) {
        self.death = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ItemDrop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.itemid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.death = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.death {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.itemid {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.death {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ItemDrop {
        CCSUsrMsg_ItemDrop::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "itemid",
                |m: &CCSUsrMsg_ItemDrop| { &m.itemid },
                |m: &mut CCSUsrMsg_ItemDrop| { &mut m.itemid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "death",
                |m: &CCSUsrMsg_ItemDrop| { &m.death },
                |m: &mut CCSUsrMsg_ItemDrop| { &mut m.death },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ItemDrop>(
                "CCSUsrMsg_ItemDrop",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ItemDrop {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ItemDrop> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ItemDrop::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ItemDrop {
    fn clear(&mut self) {
        self.itemid = ::std::option::Option::None;
        self.death = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ItemDrop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ItemDrop {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_GlowPropTurnOff {
    // message fields
    entidx: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_GlowPropTurnOff {
    fn default() -> &'a CCSUsrMsg_GlowPropTurnOff {
        <CCSUsrMsg_GlowPropTurnOff as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_GlowPropTurnOff {
    pub fn new() -> CCSUsrMsg_GlowPropTurnOff {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;


    pub fn get_entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }
    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_GlowPropTurnOff {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entidx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_GlowPropTurnOff {
        CCSUsrMsg_GlowPropTurnOff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entidx",
                |m: &CCSUsrMsg_GlowPropTurnOff| { &m.entidx },
                |m: &mut CCSUsrMsg_GlowPropTurnOff| { &mut m.entidx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_GlowPropTurnOff>(
                "CCSUsrMsg_GlowPropTurnOff",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_GlowPropTurnOff {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_GlowPropTurnOff> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_GlowPropTurnOff::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_GlowPropTurnOff {
    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_GlowPropTurnOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_GlowPropTurnOff {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RoundBackupFilenames {
    // message fields
    count: ::std::option::Option<i32>,
    index: ::std::option::Option<i32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    nicename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundBackupFilenames {
    fn default() -> &'a CCSUsrMsg_RoundBackupFilenames {
        <CCSUsrMsg_RoundBackupFilenames as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundBackupFilenames {
    pub fn new() -> CCSUsrMsg_RoundBackupFilenames {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 index = 2;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string filename = 3;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nicename = 4;


    pub fn get_nicename(&self) -> &str {
        match self.nicename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nicename(&mut self) {
        self.nicename.clear();
    }

    pub fn has_nicename(&self) -> bool {
        self.nicename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nicename(&mut self, v: ::std::string::String) {
        self.nicename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nicename(&mut self) -> &mut ::std::string::String {
        if self.nicename.is_none() {
            self.nicename.set_default();
        }
        self.nicename.as_mut().unwrap()
    }

    // Take field
    pub fn take_nicename(&mut self) -> ::std::string::String {
        self.nicename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundBackupFilenames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nicename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.nicename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.nicename.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RoundBackupFilenames {
        CCSUsrMsg_RoundBackupFilenames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &CCSUsrMsg_RoundBackupFilenames| { &m.count },
                |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &CCSUsrMsg_RoundBackupFilenames| { &m.index },
                |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &CCSUsrMsg_RoundBackupFilenames| { &m.filename },
                |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nicename",
                |m: &CCSUsrMsg_RoundBackupFilenames| { &m.nicename },
                |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.nicename },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RoundBackupFilenames>(
                "CCSUsrMsg_RoundBackupFilenames",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundBackupFilenames {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RoundBackupFilenames> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RoundBackupFilenames::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RoundBackupFilenames {
    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.filename.clear();
        self.nicename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RoundBackupFilenames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundBackupFilenames {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SSUI {
    // message fields
    show: ::std::option::Option<bool>,
    start_time: ::std::option::Option<f32>,
    end_time: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SSUI {
    fn default() -> &'a CCSUsrMsg_SSUI {
        <CCSUsrMsg_SSUI as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SSUI {
    pub fn new() -> CCSUsrMsg_SSUI {
        ::std::default::Default::default()
    }

    // optional bool show = 1;


    pub fn get_show(&self) -> bool {
        self.show.unwrap_or(false)
    }
    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    // optional float start_time = 2;


    pub fn get_start_time(&self) -> f32 {
        self.start_time.unwrap_or(0.)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional float end_time = 3;


    pub fn get_end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SSUI {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.end_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.show {
            my_size += 2;
        }
        if let Some(v) = self.start_time {
            my_size += 5;
        }
        if let Some(v) = self.end_time {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.show {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SSUI {
        CCSUsrMsg_SSUI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show",
                |m: &CCSUsrMsg_SSUI| { &m.show },
                |m: &mut CCSUsrMsg_SSUI| { &mut m.show },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "start_time",
                |m: &CCSUsrMsg_SSUI| { &m.start_time },
                |m: &mut CCSUsrMsg_SSUI| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "end_time",
                |m: &CCSUsrMsg_SSUI| { &m.end_time },
                |m: &mut CCSUsrMsg_SSUI| { &mut m.end_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SSUI>(
                "CCSUsrMsg_SSUI",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SSUI {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SSUI> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SSUI::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SSUI {
    fn clear(&mut self) {
        self.show = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SSUI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SSUI {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SurvivalStats {
    // message fields
    xuid: ::std::option::Option<u64>,
    pub facts: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Fact>,
    pub users: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Placement>,
    pub damages: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Damage>,
    ticknumber: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats {
    fn default() -> &'a CCSUsrMsg_SurvivalStats {
        <CCSUsrMsg_SurvivalStats as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats {
    pub fn new() -> CCSUsrMsg_SurvivalStats {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;


    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }
    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // repeated .CCSUsrMsg_SurvivalStats.Fact facts = 2;


    pub fn get_facts(&self) -> &[CCSUsrMsg_SurvivalStats_Fact] {
        &self.facts
    }
    pub fn clear_facts(&mut self) {
        self.facts.clear();
    }

    // Param is passed by value, moved
    pub fn set_facts(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Fact>) {
        self.facts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_facts(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Fact> {
        &mut self.facts
    }

    // Take field
    pub fn take_facts(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Fact> {
        ::std::mem::replace(&mut self.facts, ::protobuf::RepeatedField::new())
    }

    // repeated .CCSUsrMsg_SurvivalStats.Placement users = 3;


    pub fn get_users(&self) -> &[CCSUsrMsg_SurvivalStats_Placement] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Placement>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Placement> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Placement> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }

    // repeated .CCSUsrMsg_SurvivalStats.Damage damages = 5;


    pub fn get_damages(&self) -> &[CCSUsrMsg_SurvivalStats_Damage] {
        &self.damages
    }
    pub fn clear_damages(&mut self) {
        self.damages.clear();
    }

    // Param is passed by value, moved
    pub fn set_damages(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Damage>) {
        self.damages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_damages(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Damage> {
        &mut self.damages
    }

    // Take field
    pub fn take_damages(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_SurvivalStats_Damage> {
        ::std::mem::replace(&mut self.damages, ::protobuf::RepeatedField::new())
    }

    // optional int32 ticknumber = 4;


    pub fn get_ticknumber(&self) -> i32 {
        self.ticknumber.unwrap_or(0)
    }
    pub fn clear_ticknumber(&mut self) {
        self.ticknumber = ::std::option::Option::None;
    }

    pub fn has_ticknumber(&self) -> bool {
        self.ticknumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticknumber(&mut self, v: i32) {
        self.ticknumber = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats {
    fn is_initialized(&self) -> bool {
        for v in &self.facts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.damages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.xuid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.facts)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.damages)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ticknumber = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.facts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.damages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.ticknumber {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        for v in &self.facts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.users {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.damages {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.ticknumber {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SurvivalStats {
        CCSUsrMsg_SurvivalStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "xuid",
                |m: &CCSUsrMsg_SurvivalStats| { &m.xuid },
                |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_SurvivalStats_Fact>>(
                "facts",
                |m: &CCSUsrMsg_SurvivalStats| { &m.facts },
                |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.facts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_SurvivalStats_Placement>>(
                "users",
                |m: &CCSUsrMsg_SurvivalStats| { &m.users },
                |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.users },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_SurvivalStats_Damage>>(
                "damages",
                |m: &CCSUsrMsg_SurvivalStats| { &m.damages },
                |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.damages },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ticknumber",
                |m: &CCSUsrMsg_SurvivalStats| { &m.ticknumber },
                |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.ticknumber },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SurvivalStats>(
                "CCSUsrMsg_SurvivalStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SurvivalStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SurvivalStats::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SurvivalStats {
    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.facts.clear();
        self.users.clear();
        self.damages.clear();
        self.ticknumber = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SurvivalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SurvivalStats_Fact {
    // message fields
    field_type: ::std::option::Option<i32>,
    display: ::std::option::Option<i32>,
    value: ::std::option::Option<i32>,
    interestingness: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats_Fact {
    fn default() -> &'a CCSUsrMsg_SurvivalStats_Fact {
        <CCSUsrMsg_SurvivalStats_Fact as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats_Fact {
    pub fn new() -> CCSUsrMsg_SurvivalStats_Fact {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional int32 display = 2;


    pub fn get_display(&self) -> i32 {
        self.display.unwrap_or(0)
    }
    pub fn clear_display(&mut self) {
        self.display = ::std::option::Option::None;
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: i32) {
        self.display = ::std::option::Option::Some(v);
    }

    // optional int32 value = 3;


    pub fn get_value(&self) -> i32 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional float interestingness = 4;


    pub fn get_interestingness(&self) -> f32 {
        self.interestingness.unwrap_or(0.)
    }
    pub fn clear_interestingness(&mut self) {
        self.interestingness = ::std::option::Option::None;
    }

    pub fn has_interestingness(&self) -> bool {
        self.interestingness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interestingness(&mut self, v: f32) {
        self.interestingness = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats_Fact {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.display = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.interestingness = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.display {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.interestingness {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.display {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.interestingness {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SurvivalStats_Fact {
        CCSUsrMsg_SurvivalStats_Fact::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &CCSUsrMsg_SurvivalStats_Fact| { &m.field_type },
                |m: &mut CCSUsrMsg_SurvivalStats_Fact| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "display",
                |m: &CCSUsrMsg_SurvivalStats_Fact| { &m.display },
                |m: &mut CCSUsrMsg_SurvivalStats_Fact| { &mut m.display },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "value",
                |m: &CCSUsrMsg_SurvivalStats_Fact| { &m.value },
                |m: &mut CCSUsrMsg_SurvivalStats_Fact| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "interestingness",
                |m: &CCSUsrMsg_SurvivalStats_Fact| { &m.interestingness },
                |m: &mut CCSUsrMsg_SurvivalStats_Fact| { &mut m.interestingness },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SurvivalStats_Fact>(
                "CCSUsrMsg_SurvivalStats.Fact",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats_Fact {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SurvivalStats_Fact> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SurvivalStats_Fact::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SurvivalStats_Fact {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.display = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.interestingness = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SurvivalStats_Fact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats_Fact {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SurvivalStats_Placement {
    // message fields
    xuid: ::std::option::Option<u64>,
    teamnumber: ::std::option::Option<i32>,
    placement: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats_Placement {
    fn default() -> &'a CCSUsrMsg_SurvivalStats_Placement {
        <CCSUsrMsg_SurvivalStats_Placement as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats_Placement {
    pub fn new() -> CCSUsrMsg_SurvivalStats_Placement {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;


    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }
    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 teamnumber = 2;


    pub fn get_teamnumber(&self) -> i32 {
        self.teamnumber.unwrap_or(0)
    }
    pub fn clear_teamnumber(&mut self) {
        self.teamnumber = ::std::option::Option::None;
    }

    pub fn has_teamnumber(&self) -> bool {
        self.teamnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamnumber(&mut self, v: i32) {
        self.teamnumber = ::std::option::Option::Some(v);
    }

    // optional int32 placement = 3;


    pub fn get_placement(&self) -> i32 {
        self.placement.unwrap_or(0)
    }
    pub fn clear_placement(&mut self) {
        self.placement = ::std::option::Option::None;
    }

    pub fn has_placement(&self) -> bool {
        self.placement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placement(&mut self, v: i32) {
        self.placement = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats_Placement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.xuid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.teamnumber = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.placement = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.teamnumber {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.placement {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.teamnumber {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.placement {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SurvivalStats_Placement {
        CCSUsrMsg_SurvivalStats_Placement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "xuid",
                |m: &CCSUsrMsg_SurvivalStats_Placement| { &m.xuid },
                |m: &mut CCSUsrMsg_SurvivalStats_Placement| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "teamnumber",
                |m: &CCSUsrMsg_SurvivalStats_Placement| { &m.teamnumber },
                |m: &mut CCSUsrMsg_SurvivalStats_Placement| { &mut m.teamnumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "placement",
                |m: &CCSUsrMsg_SurvivalStats_Placement| { &m.placement },
                |m: &mut CCSUsrMsg_SurvivalStats_Placement| { &mut m.placement },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SurvivalStats_Placement>(
                "CCSUsrMsg_SurvivalStats.Placement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats_Placement {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SurvivalStats_Placement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SurvivalStats_Placement::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SurvivalStats_Placement {
    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.teamnumber = ::std::option::Option::None;
        self.placement = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SurvivalStats_Placement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats_Placement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_SurvivalStats_Damage {
    // message fields
    xuid: ::std::option::Option<u64>,
    to: ::std::option::Option<i32>,
    to_hits: ::std::option::Option<i32>,
    from: ::std::option::Option<i32>,
    from_hits: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats_Damage {
    fn default() -> &'a CCSUsrMsg_SurvivalStats_Damage {
        <CCSUsrMsg_SurvivalStats_Damage as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats_Damage {
    pub fn new() -> CCSUsrMsg_SurvivalStats_Damage {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;


    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }
    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 to = 2;


    pub fn get_to(&self) -> i32 {
        self.to.unwrap_or(0)
    }
    pub fn clear_to(&mut self) {
        self.to = ::std::option::Option::None;
    }

    pub fn has_to(&self) -> bool {
        self.to.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: i32) {
        self.to = ::std::option::Option::Some(v);
    }

    // optional int32 to_hits = 3;


    pub fn get_to_hits(&self) -> i32 {
        self.to_hits.unwrap_or(0)
    }
    pub fn clear_to_hits(&mut self) {
        self.to_hits = ::std::option::Option::None;
    }

    pub fn has_to_hits(&self) -> bool {
        self.to_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_hits(&mut self, v: i32) {
        self.to_hits = ::std::option::Option::Some(v);
    }

    // optional int32 from = 4;


    pub fn get_from(&self) -> i32 {
        self.from.unwrap_or(0)
    }
    pub fn clear_from(&mut self) {
        self.from = ::std::option::Option::None;
    }

    pub fn has_from(&self) -> bool {
        self.from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: i32) {
        self.from = ::std::option::Option::Some(v);
    }

    // optional int32 from_hits = 5;


    pub fn get_from_hits(&self) -> i32 {
        self.from_hits.unwrap_or(0)
    }
    pub fn clear_from_hits(&mut self) {
        self.from_hits = ::std::option::Option::None;
    }

    pub fn has_from_hits(&self) -> bool {
        self.from_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_hits(&mut self, v: i32) {
        self.from_hits = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats_Damage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.xuid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.to = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.to_hits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.from = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.from_hits = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.to {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.to_hits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_hits {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.to {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.to_hits {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.from {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.from_hits {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_SurvivalStats_Damage {
        CCSUsrMsg_SurvivalStats_Damage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "xuid",
                |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.xuid },
                |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "to",
                |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.to },
                |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.to },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "to_hits",
                |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.to_hits },
                |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.to_hits },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "from",
                |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.from },
                |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "from_hits",
                |m: &CCSUsrMsg_SurvivalStats_Damage| { &m.from_hits },
                |m: &mut CCSUsrMsg_SurvivalStats_Damage| { &mut m.from_hits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_SurvivalStats_Damage>(
                "CCSUsrMsg_SurvivalStats.Damage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats_Damage {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_SurvivalStats_Damage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_SurvivalStats_Damage::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_SurvivalStats_Damage {
    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.to = ::std::option::Option::None;
        self.to_hits = ::std::option::Option::None;
        self.from = ::std::option::Option::None;
        self.from_hits = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_SurvivalStats_Damage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats_Damage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_EndOfMatchAllPlayersData {
    // message fields
    pub allplayerdata: ::protobuf::RepeatedField<CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData>,
    scene: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EndOfMatchAllPlayersData {
    fn default() -> &'a CCSUsrMsg_EndOfMatchAllPlayersData {
        <CCSUsrMsg_EndOfMatchAllPlayersData as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EndOfMatchAllPlayersData {
    pub fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData {
        ::std::default::Default::default()
    }

    // repeated .CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData allplayerdata = 1;


    pub fn get_allplayerdata(&self) -> &[CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData] {
        &self.allplayerdata
    }
    pub fn clear_allplayerdata(&mut self) {
        self.allplayerdata.clear();
    }

    // Param is passed by value, moved
    pub fn set_allplayerdata(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData>) {
        self.allplayerdata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allplayerdata(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData> {
        &mut self.allplayerdata
    }

    // Take field
    pub fn take_allplayerdata(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData> {
        ::std::mem::replace(&mut self.allplayerdata, ::protobuf::RepeatedField::new())
    }

    // optional int32 scene = 2;


    pub fn get_scene(&self) -> i32 {
        self.scene.unwrap_or(0)
    }
    pub fn clear_scene(&mut self) {
        self.scene = ::std::option::Option::None;
    }

    pub fn has_scene(&self) -> bool {
        self.scene.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scene(&mut self, v: i32) {
        self.scene = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_EndOfMatchAllPlayersData {
    fn is_initialized(&self) -> bool {
        for v in &self.allplayerdata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allplayerdata)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.scene = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allplayerdata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.scene {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allplayerdata {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.scene {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData {
        CCSUsrMsg_EndOfMatchAllPlayersData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData>>(
                "allplayerdata",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData| { &m.allplayerdata },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData| { &mut m.allplayerdata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "scene",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData| { &m.scene },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData| { &mut m.scene },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_EndOfMatchAllPlayersData>(
                "CCSUsrMsg_EndOfMatchAllPlayersData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_EndOfMatchAllPlayersData {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_EndOfMatchAllPlayersData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_EndOfMatchAllPlayersData::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_EndOfMatchAllPlayersData {
    fn clear(&mut self) {
        self.allplayerdata.clear();
        self.scene = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_EndOfMatchAllPlayersData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_EndOfMatchAllPlayersData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
    // message fields
    eaccolade: ::std::option::Option<i32>,
    value: ::std::option::Option<f32>,
    position: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
    fn default() -> &'a CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
        <CCSUsrMsg_EndOfMatchAllPlayersData_Accolade as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
    pub fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
        ::std::default::Default::default()
    }

    // optional int32 eaccolade = 1;


    pub fn get_eaccolade(&self) -> i32 {
        self.eaccolade.unwrap_or(0)
    }
    pub fn clear_eaccolade(&mut self) {
        self.eaccolade = ::std::option::Option::None;
    }

    pub fn has_eaccolade(&self) -> bool {
        self.eaccolade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eaccolade(&mut self, v: i32) {
        self.eaccolade = ::std::option::Option::Some(v);
    }

    // optional float value = 2;


    pub fn get_value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional int32 position = 3;


    pub fn get_position(&self) -> i32 {
        self.position.unwrap_or(0)
    }
    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: i32) {
        self.position = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eaccolade = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.position = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eaccolade {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += 5;
        }
        if let Some(v) = self.position {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eaccolade {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.position {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
        CCSUsrMsg_EndOfMatchAllPlayersData_Accolade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eaccolade",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_Accolade| { &m.eaccolade },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_Accolade| { &mut m.eaccolade },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_Accolade| { &m.value },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_Accolade| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "position",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_Accolade| { &m.position },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_Accolade| { &mut m.position },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_EndOfMatchAllPlayersData_Accolade>(
                "CCSUsrMsg_EndOfMatchAllPlayersData.Accolade",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_EndOfMatchAllPlayersData_Accolade> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_EndOfMatchAllPlayersData_Accolade::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
    fn clear(&mut self) {
        self.eaccolade = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.position = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
    // message fields
    entindex: ::std::option::Option<i32>,
    xuid: ::std::option::Option<u64>,
    name: ::protobuf::SingularField<::std::string::String>,
    teamnumber: ::std::option::Option<i32>,
    pub nomination: ::protobuf::SingularPtrField<CCSUsrMsg_EndOfMatchAllPlayersData_Accolade>,
    pub items: ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    playercolor: ::std::option::Option<i32>,
    isbot: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
    fn default() -> &'a CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
        <CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
    pub fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
        ::std::default::Default::default()
    }

    // optional int32 entindex = 1;


    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }
    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional uint64 xuid = 2;


    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }
    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 teamnumber = 4;


    pub fn get_teamnumber(&self) -> i32 {
        self.teamnumber.unwrap_or(0)
    }
    pub fn clear_teamnumber(&mut self) {
        self.teamnumber = ::std::option::Option::None;
    }

    pub fn has_teamnumber(&self) -> bool {
        self.teamnumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_teamnumber(&mut self, v: i32) {
        self.teamnumber = ::std::option::Option::Some(v);
    }

    // optional .CCSUsrMsg_EndOfMatchAllPlayersData.Accolade nomination = 5;


    pub fn get_nomination(&self) -> &CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
        self.nomination.as_ref().unwrap_or_else(|| <CCSUsrMsg_EndOfMatchAllPlayersData_Accolade as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nomination(&mut self) {
        self.nomination.clear();
    }

    pub fn has_nomination(&self) -> bool {
        self.nomination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nomination(&mut self, v: CCSUsrMsg_EndOfMatchAllPlayersData_Accolade) {
        self.nomination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nomination(&mut self) -> &mut CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
        if self.nomination.is_none() {
            self.nomination.set_default();
        }
        self.nomination.as_mut().unwrap()
    }

    // Take field
    pub fn take_nomination(&mut self) -> CCSUsrMsg_EndOfMatchAllPlayersData_Accolade {
        self.nomination.take().unwrap_or_else(|| CCSUsrMsg_EndOfMatchAllPlayersData_Accolade::new())
    }

    // repeated .CEconItemPreviewDataBlock items = 6;


    pub fn get_items(&self) -> &[super::cstrike15_gcmessages::CEconItemPreviewDataBlock] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // optional int32 playercolor = 7;


    pub fn get_playercolor(&self) -> i32 {
        self.playercolor.unwrap_or(0)
    }
    pub fn clear_playercolor(&mut self) {
        self.playercolor = ::std::option::Option::None;
    }

    pub fn has_playercolor(&self) -> bool {
        self.playercolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playercolor(&mut self, v: i32) {
        self.playercolor = ::std::option::Option::Some(v);
    }

    // optional bool isbot = 8;


    pub fn get_isbot(&self) -> bool {
        self.isbot.unwrap_or(false)
    }
    pub fn clear_isbot(&mut self) {
        self.isbot = ::std::option::Option::None;
    }

    pub fn has_isbot(&self) -> bool {
        self.isbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isbot(&mut self, v: bool) {
        self.isbot = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
    fn is_initialized(&self) -> bool {
        for v in &self.nomination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.xuid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.teamnumber = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nomination)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.playercolor = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isbot = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.teamnumber {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nomination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.playercolor {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isbot {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.teamnumber {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.nomination.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.playercolor {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.isbot {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
        CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entindex",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &m.entindex },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &mut m.entindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "xuid",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &m.xuid },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &m.name },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "teamnumber",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &m.teamnumber },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &mut m.teamnumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_EndOfMatchAllPlayersData_Accolade>>(
                "nomination",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &m.nomination },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &mut m.nomination },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>>(
                "items",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &m.items },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "playercolor",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &m.playercolor },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &mut m.playercolor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isbot",
                |m: &CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &m.isbot },
                |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData| { &mut m.isbot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData>(
                "CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
    fn clear(&mut self) {
        self.entindex = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.name.clear();
        self.teamnumber = ::std::option::Option::None;
        self.nomination.clear();
        self.items.clear();
        self.playercolor = ::std::option::Option::None;
        self.isbot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_EndOfMatchAllPlayersData_PlayerData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RoundImpactScoreData {
    // message fields
    pub init_conditions: ::protobuf::SingularPtrField<CCSUsrMsg_RoundImpactScoreData_InitialConditions>,
    pub all_ris_event_data: ::protobuf::RepeatedField<CCSUsrMsg_RoundImpactScoreData_RisEvent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundImpactScoreData {
    fn default() -> &'a CCSUsrMsg_RoundImpactScoreData {
        <CCSUsrMsg_RoundImpactScoreData as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundImpactScoreData {
    pub fn new() -> CCSUsrMsg_RoundImpactScoreData {
        ::std::default::Default::default()
    }

    // optional .CCSUsrMsg_RoundImpactScoreData.InitialConditions init_conditions = 1;


    pub fn get_init_conditions(&self) -> &CCSUsrMsg_RoundImpactScoreData_InitialConditions {
        self.init_conditions.as_ref().unwrap_or_else(|| <CCSUsrMsg_RoundImpactScoreData_InitialConditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_init_conditions(&mut self) {
        self.init_conditions.clear();
    }

    pub fn has_init_conditions(&self) -> bool {
        self.init_conditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_init_conditions(&mut self, v: CCSUsrMsg_RoundImpactScoreData_InitialConditions) {
        self.init_conditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_init_conditions(&mut self) -> &mut CCSUsrMsg_RoundImpactScoreData_InitialConditions {
        if self.init_conditions.is_none() {
            self.init_conditions.set_default();
        }
        self.init_conditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_init_conditions(&mut self) -> CCSUsrMsg_RoundImpactScoreData_InitialConditions {
        self.init_conditions.take().unwrap_or_else(|| CCSUsrMsg_RoundImpactScoreData_InitialConditions::new())
    }

    // repeated .CCSUsrMsg_RoundImpactScoreData.RisEvent all_ris_event_data = 2;


    pub fn get_all_ris_event_data(&self) -> &[CCSUsrMsg_RoundImpactScoreData_RisEvent] {
        &self.all_ris_event_data
    }
    pub fn clear_all_ris_event_data(&mut self) {
        self.all_ris_event_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_all_ris_event_data(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_RoundImpactScoreData_RisEvent>) {
        self.all_ris_event_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_all_ris_event_data(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_RoundImpactScoreData_RisEvent> {
        &mut self.all_ris_event_data
    }

    // Take field
    pub fn take_all_ris_event_data(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_RoundImpactScoreData_RisEvent> {
        ::std::mem::replace(&mut self.all_ris_event_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundImpactScoreData {
    fn is_initialized(&self) -> bool {
        for v in &self.init_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.all_ris_event_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.init_conditions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.all_ris_event_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.init_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.all_ris_event_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.init_conditions.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.all_ris_event_data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RoundImpactScoreData {
        CCSUsrMsg_RoundImpactScoreData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_RoundImpactScoreData_InitialConditions>>(
                "init_conditions",
                |m: &CCSUsrMsg_RoundImpactScoreData| { &m.init_conditions },
                |m: &mut CCSUsrMsg_RoundImpactScoreData| { &mut m.init_conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_RoundImpactScoreData_RisEvent>>(
                "all_ris_event_data",
                |m: &CCSUsrMsg_RoundImpactScoreData| { &m.all_ris_event_data },
                |m: &mut CCSUsrMsg_RoundImpactScoreData| { &mut m.all_ris_event_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RoundImpactScoreData>(
                "CCSUsrMsg_RoundImpactScoreData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundImpactScoreData {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RoundImpactScoreData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RoundImpactScoreData::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RoundImpactScoreData {
    fn clear(&mut self) {
        self.init_conditions.clear();
        self.all_ris_event_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RoundImpactScoreData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundImpactScoreData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RoundImpactScoreData_RisEvent {
    // message fields
    timestamp: ::std::option::Option<f32>,
    terrorist_odds: ::std::option::Option<i32>,
    ct_alive: ::std::option::Option<i32>,
    t_alive: ::std::option::Option<i32>,
    pub victim_data: ::protobuf::SingularPtrField<CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim>,
    pub objective_data: ::protobuf::SingularPtrField<CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective>,
    pub all_damage_data: ::protobuf::RepeatedField<CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundImpactScoreData_RisEvent {
    fn default() -> &'a CCSUsrMsg_RoundImpactScoreData_RisEvent {
        <CCSUsrMsg_RoundImpactScoreData_RisEvent as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundImpactScoreData_RisEvent {
    pub fn new() -> CCSUsrMsg_RoundImpactScoreData_RisEvent {
        ::std::default::Default::default()
    }

    // optional float timestamp = 1;


    pub fn get_timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 terrorist_odds = 2;


    pub fn get_terrorist_odds(&self) -> i32 {
        self.terrorist_odds.unwrap_or(0)
    }
    pub fn clear_terrorist_odds(&mut self) {
        self.terrorist_odds = ::std::option::Option::None;
    }

    pub fn has_terrorist_odds(&self) -> bool {
        self.terrorist_odds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terrorist_odds(&mut self, v: i32) {
        self.terrorist_odds = ::std::option::Option::Some(v);
    }

    // optional int32 ct_alive = 3;


    pub fn get_ct_alive(&self) -> i32 {
        self.ct_alive.unwrap_or(0)
    }
    pub fn clear_ct_alive(&mut self) {
        self.ct_alive = ::std::option::Option::None;
    }

    pub fn has_ct_alive(&self) -> bool {
        self.ct_alive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_alive(&mut self, v: i32) {
        self.ct_alive = ::std::option::Option::Some(v);
    }

    // optional int32 t_alive = 4;


    pub fn get_t_alive(&self) -> i32 {
        self.t_alive.unwrap_or(0)
    }
    pub fn clear_t_alive(&mut self) {
        self.t_alive = ::std::option::Option::None;
    }

    pub fn has_t_alive(&self) -> bool {
        self.t_alive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t_alive(&mut self, v: i32) {
        self.t_alive = ::std::option::Option::Some(v);
    }

    // optional .CCSUsrMsg_RoundImpactScoreData.RisEvent.Victim victim_data = 5;


    pub fn get_victim_data(&self) -> &CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
        self.victim_data.as_ref().unwrap_or_else(|| <CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim as ::protobuf::Message>::default_instance())
    }
    pub fn clear_victim_data(&mut self) {
        self.victim_data.clear();
    }

    pub fn has_victim_data(&self) -> bool {
        self.victim_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_data(&mut self, v: CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim) {
        self.victim_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_victim_data(&mut self) -> &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
        if self.victim_data.is_none() {
            self.victim_data.set_default();
        }
        self.victim_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_victim_data(&mut self) -> CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
        self.victim_data.take().unwrap_or_else(|| CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim::new())
    }

    // optional .CCSUsrMsg_RoundImpactScoreData.RisEvent.Objective objective_data = 6;


    pub fn get_objective_data(&self) -> &CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
        self.objective_data.as_ref().unwrap_or_else(|| <CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective as ::protobuf::Message>::default_instance())
    }
    pub fn clear_objective_data(&mut self) {
        self.objective_data.clear();
    }

    pub fn has_objective_data(&self) -> bool {
        self.objective_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objective_data(&mut self, v: CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective) {
        self.objective_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objective_data(&mut self) -> &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
        if self.objective_data.is_none() {
            self.objective_data.set_default();
        }
        self.objective_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_objective_data(&mut self) -> CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
        self.objective_data.take().unwrap_or_else(|| CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective::new())
    }

    // repeated .CCSUsrMsg_RoundImpactScoreData.RisEvent.Damage all_damage_data = 7;


    pub fn get_all_damage_data(&self) -> &[CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage] {
        &self.all_damage_data
    }
    pub fn clear_all_damage_data(&mut self) {
        self.all_damage_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_all_damage_data(&mut self, v: ::protobuf::RepeatedField<CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage>) {
        self.all_damage_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_all_damage_data(&mut self) -> &mut ::protobuf::RepeatedField<CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage> {
        &mut self.all_damage_data
    }

    // Take field
    pub fn take_all_damage_data(&mut self) -> ::protobuf::RepeatedField<CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage> {
        ::std::mem::replace(&mut self.all_damage_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundImpactScoreData_RisEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.victim_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.objective_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.all_damage_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.terrorist_odds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ct_alive = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.t_alive = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.victim_data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.objective_data)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.all_damage_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        if let Some(v) = self.terrorist_odds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ct_alive {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.t_alive {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.victim_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.objective_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.all_damage_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.terrorist_odds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ct_alive {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.t_alive {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.victim_data.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.objective_data.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.all_damage_data {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RoundImpactScoreData_RisEvent {
        CCSUsrMsg_RoundImpactScoreData_RisEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "timestamp",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent| { &m.timestamp },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "terrorist_odds",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent| { &m.terrorist_odds },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent| { &mut m.terrorist_odds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ct_alive",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent| { &m.ct_alive },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent| { &mut m.ct_alive },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "t_alive",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent| { &m.t_alive },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent| { &mut m.t_alive },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim>>(
                "victim_data",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent| { &m.victim_data },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent| { &mut m.victim_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective>>(
                "objective_data",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent| { &m.objective_data },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent| { &mut m.objective_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage>>(
                "all_damage_data",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent| { &m.all_damage_data },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent| { &mut m.all_damage_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RoundImpactScoreData_RisEvent>(
                "CCSUsrMsg_RoundImpactScoreData.RisEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundImpactScoreData_RisEvent {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RoundImpactScoreData_RisEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RoundImpactScoreData_RisEvent::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RoundImpactScoreData_RisEvent {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.terrorist_odds = ::std::option::Option::None;
        self.ct_alive = ::std::option::Option::None;
        self.t_alive = ::std::option::Option::None;
        self.victim_data.clear();
        self.objective_data.clear();
        self.all_damage_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RoundImpactScoreData_RisEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundImpactScoreData_RisEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
    // message fields
    team_number: ::std::option::Option<i32>,
    entindex: ::std::option::Option<i32>,
    xuid: ::std::option::Option<u64>,
    color: ::std::option::Option<i32>,
    is_bot: ::std::option::Option<bool>,
    is_dead: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
    fn default() -> &'a CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
        <CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
    pub fn new() -> CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
        ::std::default::Default::default()
    }

    // optional int32 team_number = 1;


    pub fn get_team_number(&self) -> i32 {
        self.team_number.unwrap_or(0)
    }
    pub fn clear_team_number(&mut self) {
        self.team_number = ::std::option::Option::None;
    }

    pub fn has_team_number(&self) -> bool {
        self.team_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_number(&mut self, v: i32) {
        self.team_number = ::std::option::Option::Some(v);
    }

    // optional int32 entindex = 2;


    pub fn get_entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }
    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional uint64 xuid = 3;


    pub fn get_xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }
    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 color = 4;


    pub fn get_color(&self) -> i32 {
        self.color.unwrap_or(0)
    }
    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: i32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional bool is_bot = 5;


    pub fn get_is_bot(&self) -> bool {
        self.is_bot.unwrap_or(false)
    }
    pub fn clear_is_bot(&mut self) {
        self.is_bot = ::std::option::Option::None;
    }

    pub fn has_is_bot(&self) -> bool {
        self.is_bot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_bot(&mut self, v: bool) {
        self.is_bot = ::std::option::Option::Some(v);
    }

    // optional bool is_dead = 6;


    pub fn get_is_dead(&self) -> bool {
        self.is_dead.unwrap_or(false)
    }
    pub fn clear_is_dead(&mut self) {
        self.is_dead = ::std::option::Option::None;
    }

    pub fn has_is_dead(&self) -> bool {
        self.is_dead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dead(&mut self, v: bool) {
        self.is_dead = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.team_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.entindex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.xuid = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.color = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_bot = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_dead = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.team_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_bot {
            my_size += 2;
        }
        if let Some(v) = self.is_dead {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.team_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.color {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.is_bot {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_dead {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
        CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "team_number",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &m.team_number },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &mut m.team_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "entindex",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &m.entindex },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &mut m.entindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "xuid",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &m.xuid },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "color",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &m.color },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_bot",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &m.is_bot },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &mut m.is_bot },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_dead",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &m.is_dead },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim| { &mut m.is_dead },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim>(
                "CCSUsrMsg_RoundImpactScoreData.RisEvent.Victim",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
    fn clear(&mut self) {
        self.team_number = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.is_bot = ::std::option::Option::None;
        self.is_dead = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundImpactScoreData_RisEvent_Victim {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
    // message fields
    field_type: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
    fn default() -> &'a CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
        <CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
    pub fn new() -> CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
        CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective| { &m.field_type },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective>(
                "CCSUsrMsg_RoundImpactScoreData.RisEvent.Objective",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundImpactScoreData_RisEvent_Objective {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
    // message fields
    target_entindex: ::std::option::Option<i32>,
    target_xuid: ::std::option::Option<u64>,
    health_removed: ::std::option::Option<i32>,
    num_hits: ::std::option::Option<i32>,
    return_health_removed: ::std::option::Option<i32>,
    num_return_hits: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
    fn default() -> &'a CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
        <CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
    pub fn new() -> CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
        ::std::default::Default::default()
    }

    // optional int32 target_entindex = 1;


    pub fn get_target_entindex(&self) -> i32 {
        self.target_entindex.unwrap_or(0)
    }
    pub fn clear_target_entindex(&mut self) {
        self.target_entindex = ::std::option::Option::None;
    }

    pub fn has_target_entindex(&self) -> bool {
        self.target_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entindex(&mut self, v: i32) {
        self.target_entindex = ::std::option::Option::Some(v);
    }

    // optional uint64 target_xuid = 2;


    pub fn get_target_xuid(&self) -> u64 {
        self.target_xuid.unwrap_or(0)
    }
    pub fn clear_target_xuid(&mut self) {
        self.target_xuid = ::std::option::Option::None;
    }

    pub fn has_target_xuid(&self) -> bool {
        self.target_xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_xuid(&mut self, v: u64) {
        self.target_xuid = ::std::option::Option::Some(v);
    }

    // optional int32 health_removed = 3;


    pub fn get_health_removed(&self) -> i32 {
        self.health_removed.unwrap_or(0)
    }
    pub fn clear_health_removed(&mut self) {
        self.health_removed = ::std::option::Option::None;
    }

    pub fn has_health_removed(&self) -> bool {
        self.health_removed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_removed(&mut self, v: i32) {
        self.health_removed = ::std::option::Option::Some(v);
    }

    // optional int32 num_hits = 4;


    pub fn get_num_hits(&self) -> i32 {
        self.num_hits.unwrap_or(0)
    }
    pub fn clear_num_hits(&mut self) {
        self.num_hits = ::std::option::Option::None;
    }

    pub fn has_num_hits(&self) -> bool {
        self.num_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits(&mut self, v: i32) {
        self.num_hits = ::std::option::Option::Some(v);
    }

    // optional int32 return_health_removed = 5;


    pub fn get_return_health_removed(&self) -> i32 {
        self.return_health_removed.unwrap_or(0)
    }
    pub fn clear_return_health_removed(&mut self) {
        self.return_health_removed = ::std::option::Option::None;
    }

    pub fn has_return_health_removed(&self) -> bool {
        self.return_health_removed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_health_removed(&mut self, v: i32) {
        self.return_health_removed = ::std::option::Option::Some(v);
    }

    // optional int32 num_return_hits = 6;


    pub fn get_num_return_hits(&self) -> i32 {
        self.num_return_hits.unwrap_or(0)
    }
    pub fn clear_num_return_hits(&mut self) {
        self.num_return_hits = ::std::option::Option::None;
    }

    pub fn has_num_return_hits(&self) -> bool {
        self.num_return_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_return_hits(&mut self, v: i32) {
        self.num_return_hits = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_entindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.target_xuid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.health_removed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_hits = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.return_health_removed = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_return_hits = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_entindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_xuid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.health_removed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_hits {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.return_health_removed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_return_hits {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_entindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_xuid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.health_removed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.num_hits {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.return_health_removed {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.num_return_hits {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
        CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "target_entindex",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &m.target_entindex },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &mut m.target_entindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "target_xuid",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &m.target_xuid },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &mut m.target_xuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "health_removed",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &m.health_removed },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &mut m.health_removed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_hits",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &m.num_hits },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &mut m.num_hits },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "return_health_removed",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &m.return_health_removed },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &mut m.return_health_removed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_return_hits",
                |m: &CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &m.num_return_hits },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage| { &mut m.num_return_hits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage>(
                "CCSUsrMsg_RoundImpactScoreData.RisEvent.Damage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
    fn clear(&mut self) {
        self.target_entindex = ::std::option::Option::None;
        self.target_xuid = ::std::option::Option::None;
        self.health_removed = ::std::option::Option::None;
        self.num_hits = ::std::option::Option::None;
        self.return_health_removed = ::std::option::Option::None;
        self.num_return_hits = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundImpactScoreData_RisEvent_Damage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RoundImpactScoreData_InitialConditions {
    // message fields
    ct_equip_value: ::std::option::Option<i32>,
    t_equip_value: ::std::option::Option<i32>,
    terrorist_odds: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundImpactScoreData_InitialConditions {
    fn default() -> &'a CCSUsrMsg_RoundImpactScoreData_InitialConditions {
        <CCSUsrMsg_RoundImpactScoreData_InitialConditions as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundImpactScoreData_InitialConditions {
    pub fn new() -> CCSUsrMsg_RoundImpactScoreData_InitialConditions {
        ::std::default::Default::default()
    }

    // optional int32 ct_equip_value = 1;


    pub fn get_ct_equip_value(&self) -> i32 {
        self.ct_equip_value.unwrap_or(0)
    }
    pub fn clear_ct_equip_value(&mut self) {
        self.ct_equip_value = ::std::option::Option::None;
    }

    pub fn has_ct_equip_value(&self) -> bool {
        self.ct_equip_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ct_equip_value(&mut self, v: i32) {
        self.ct_equip_value = ::std::option::Option::Some(v);
    }

    // optional int32 t_equip_value = 2;


    pub fn get_t_equip_value(&self) -> i32 {
        self.t_equip_value.unwrap_or(0)
    }
    pub fn clear_t_equip_value(&mut self) {
        self.t_equip_value = ::std::option::Option::None;
    }

    pub fn has_t_equip_value(&self) -> bool {
        self.t_equip_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t_equip_value(&mut self, v: i32) {
        self.t_equip_value = ::std::option::Option::Some(v);
    }

    // optional int32 terrorist_odds = 3;


    pub fn get_terrorist_odds(&self) -> i32 {
        self.terrorist_odds.unwrap_or(0)
    }
    pub fn clear_terrorist_odds(&mut self) {
        self.terrorist_odds = ::std::option::Option::None;
    }

    pub fn has_terrorist_odds(&self) -> bool {
        self.terrorist_odds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terrorist_odds(&mut self, v: i32) {
        self.terrorist_odds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundImpactScoreData_InitialConditions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ct_equip_value = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.t_equip_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.terrorist_odds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ct_equip_value {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.t_equip_value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.terrorist_odds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ct_equip_value {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.t_equip_value {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.terrorist_odds {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RoundImpactScoreData_InitialConditions {
        CCSUsrMsg_RoundImpactScoreData_InitialConditions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ct_equip_value",
                |m: &CCSUsrMsg_RoundImpactScoreData_InitialConditions| { &m.ct_equip_value },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_InitialConditions| { &mut m.ct_equip_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "t_equip_value",
                |m: &CCSUsrMsg_RoundImpactScoreData_InitialConditions| { &m.t_equip_value },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_InitialConditions| { &mut m.t_equip_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "terrorist_odds",
                |m: &CCSUsrMsg_RoundImpactScoreData_InitialConditions| { &m.terrorist_odds },
                |m: &mut CCSUsrMsg_RoundImpactScoreData_InitialConditions| { &mut m.terrorist_odds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RoundImpactScoreData_InitialConditions>(
                "CCSUsrMsg_RoundImpactScoreData.InitialConditions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundImpactScoreData_InitialConditions {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RoundImpactScoreData_InitialConditions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RoundImpactScoreData_InitialConditions::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RoundImpactScoreData_InitialConditions {
    fn clear(&mut self) {
        self.ct_equip_value = ::std::option::Option::None;
        self.t_equip_value = ::std::option::Option::None;
        self.terrorist_odds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RoundImpactScoreData_InitialConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundImpactScoreData_InitialConditions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_CurrentRoundOdds {
    // message fields
    odds: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CurrentRoundOdds {
    fn default() -> &'a CCSUsrMsg_CurrentRoundOdds {
        <CCSUsrMsg_CurrentRoundOdds as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CurrentRoundOdds {
    pub fn new() -> CCSUsrMsg_CurrentRoundOdds {
        ::std::default::Default::default()
    }

    // optional int32 odds = 1;


    pub fn get_odds(&self) -> i32 {
        self.odds.unwrap_or(0)
    }
    pub fn clear_odds(&mut self) {
        self.odds = ::std::option::Option::None;
    }

    pub fn has_odds(&self) -> bool {
        self.odds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_odds(&mut self, v: i32) {
        self.odds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_CurrentRoundOdds {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.odds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.odds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.odds {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_CurrentRoundOdds {
        CCSUsrMsg_CurrentRoundOdds::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "odds",
                |m: &CCSUsrMsg_CurrentRoundOdds| { &m.odds },
                |m: &mut CCSUsrMsg_CurrentRoundOdds| { &mut m.odds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_CurrentRoundOdds>(
                "CCSUsrMsg_CurrentRoundOdds",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_CurrentRoundOdds {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_CurrentRoundOdds> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_CurrentRoundOdds::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_CurrentRoundOdds {
    fn clear(&mut self) {
        self.odds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_CurrentRoundOdds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CurrentRoundOdds {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_DeepStats {
    // message fields
    pub stats: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DeepStats {
    fn default() -> &'a CCSUsrMsg_DeepStats {
        <CCSUsrMsg_DeepStats as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DeepStats {
    pub fn new() -> CCSUsrMsg_DeepStats {
        ::std::default::Default::default()
    }

    // optional .CMsgGCCStrike15_ClientDeepStats stats = 1;


    pub fn get_stats(&self) -> &super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats {
        self.stats.as_ref().unwrap_or_else(|| <super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats {
        self.stats.take().unwrap_or_else(|| super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_DeepStats {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_DeepStats {
        CCSUsrMsg_DeepStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats>>(
                "stats",
                |m: &CCSUsrMsg_DeepStats| { &m.stats },
                |m: &mut CCSUsrMsg_DeepStats| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_DeepStats>(
                "CCSUsrMsg_DeepStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_DeepStats {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_DeepStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_DeepStats::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_DeepStats {
    fn clear(&mut self) {
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_DeepStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DeepStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ResetHud {
    // message fields
    reset: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ResetHud {
    fn default() -> &'a CCSUsrMsg_ResetHud {
        <CCSUsrMsg_ResetHud as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ResetHud {
    pub fn new() -> CCSUsrMsg_ResetHud {
        ::std::default::Default::default()
    }

    // optional bool reset = 1;


    pub fn get_reset(&self) -> bool {
        self.reset.unwrap_or(false)
    }
    pub fn clear_reset(&mut self) {
        self.reset = ::std::option::Option::None;
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ResetHud {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reset = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reset {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reset {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ResetHud {
        CCSUsrMsg_ResetHud::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reset",
                |m: &CCSUsrMsg_ResetHud| { &m.reset },
                |m: &mut CCSUsrMsg_ResetHud| { &mut m.reset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ResetHud>(
                "CCSUsrMsg_ResetHud",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ResetHud {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ResetHud> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ResetHud::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ResetHud {
    fn clear(&mut self) {
        self.reset = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ResetHud {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ResetHud {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_GameTitle {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_GameTitle {
    fn default() -> &'a CCSUsrMsg_GameTitle {
        <CCSUsrMsg_GameTitle as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_GameTitle {
    pub fn new() -> CCSUsrMsg_GameTitle {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_GameTitle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_GameTitle {
        CCSUsrMsg_GameTitle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dummy",
                |m: &CCSUsrMsg_GameTitle| { &m.dummy },
                |m: &mut CCSUsrMsg_GameTitle| { &mut m.dummy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_GameTitle>(
                "CCSUsrMsg_GameTitle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_GameTitle {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_GameTitle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_GameTitle::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_GameTitle {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_GameTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_GameTitle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_RequestState {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RequestState {
    fn default() -> &'a CCSUsrMsg_RequestState {
        <CCSUsrMsg_RequestState as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RequestState {
    pub fn new() -> CCSUsrMsg_RequestState {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_RequestState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_RequestState {
        CCSUsrMsg_RequestState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dummy",
                |m: &CCSUsrMsg_RequestState| { &m.dummy },
                |m: &mut CCSUsrMsg_RequestState| { &mut m.dummy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_RequestState>(
                "CCSUsrMsg_RequestState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_RequestState {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_RequestState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_RequestState::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_RequestState {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_RequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RequestState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_StopSpectatorMode {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_StopSpectatorMode {
    fn default() -> &'a CCSUsrMsg_StopSpectatorMode {
        <CCSUsrMsg_StopSpectatorMode as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_StopSpectatorMode {
    pub fn new() -> CCSUsrMsg_StopSpectatorMode {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_StopSpectatorMode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_StopSpectatorMode {
        CCSUsrMsg_StopSpectatorMode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dummy",
                |m: &CCSUsrMsg_StopSpectatorMode| { &m.dummy },
                |m: &mut CCSUsrMsg_StopSpectatorMode| { &mut m.dummy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_StopSpectatorMode>(
                "CCSUsrMsg_StopSpectatorMode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_StopSpectatorMode {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_StopSpectatorMode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_StopSpectatorMode::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_StopSpectatorMode {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_StopSpectatorMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_StopSpectatorMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_DisconnectToLobby {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DisconnectToLobby {
    fn default() -> &'a CCSUsrMsg_DisconnectToLobby {
        <CCSUsrMsg_DisconnectToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DisconnectToLobby {
    pub fn new() -> CCSUsrMsg_DisconnectToLobby {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_DisconnectToLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_DisconnectToLobby {
        CCSUsrMsg_DisconnectToLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dummy",
                |m: &CCSUsrMsg_DisconnectToLobby| { &m.dummy },
                |m: &mut CCSUsrMsg_DisconnectToLobby| { &mut m.dummy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_DisconnectToLobby>(
                "CCSUsrMsg_DisconnectToLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_DisconnectToLobby {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_DisconnectToLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_DisconnectToLobby::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_DisconnectToLobby {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_DisconnectToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DisconnectToLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_WarmupHasEnded {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_WarmupHasEnded {
    fn default() -> &'a CCSUsrMsg_WarmupHasEnded {
        <CCSUsrMsg_WarmupHasEnded as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_WarmupHasEnded {
    pub fn new() -> CCSUsrMsg_WarmupHasEnded {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_WarmupHasEnded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_WarmupHasEnded {
        CCSUsrMsg_WarmupHasEnded::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dummy",
                |m: &CCSUsrMsg_WarmupHasEnded| { &m.dummy },
                |m: &mut CCSUsrMsg_WarmupHasEnded| { &mut m.dummy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_WarmupHasEnded>(
                "CCSUsrMsg_WarmupHasEnded",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_WarmupHasEnded {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_WarmupHasEnded> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_WarmupHasEnded::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_WarmupHasEnded {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_WarmupHasEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_WarmupHasEnded {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ClientInfo {
    // message fields
    dummy: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ClientInfo {
    fn default() -> &'a CCSUsrMsg_ClientInfo {
        <CCSUsrMsg_ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ClientInfo {
    pub fn new() -> CCSUsrMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;


    pub fn get_dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCSUsrMsg_ClientInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dummy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ClientInfo {
        CCSUsrMsg_ClientInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dummy",
                |m: &CCSUsrMsg_ClientInfo| { &m.dummy },
                |m: &mut CCSUsrMsg_ClientInfo| { &mut m.dummy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ClientInfo>(
                "CCSUsrMsg_ClientInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ClientInfo {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ClientInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ClientInfo::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ClientInfo {
    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ClientInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CCSUsrMsg_ServerRankRevealAll {
    // message fields
    seconds_till_shutdown: ::std::option::Option<i32>,
    pub reservation: ::protobuf::SingularPtrField<super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankRevealAll {
    fn default() -> &'a CCSUsrMsg_ServerRankRevealAll {
        <CCSUsrMsg_ServerRankRevealAll as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankRevealAll {
    pub fn new() -> CCSUsrMsg_ServerRankRevealAll {
        ::std::default::Default::default()
    }

    // optional int32 seconds_till_shutdown = 1;


    pub fn get_seconds_till_shutdown(&self) -> i32 {
        self.seconds_till_shutdown.unwrap_or(0)
    }
    pub fn clear_seconds_till_shutdown(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_till_shutdown(&self) -> bool {
        self.seconds_till_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_till_shutdown(&mut self, v: i32) {
        self.seconds_till_shutdown = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve reservation = 2;


    pub fn get_reservation(&self) -> &super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.as_ref().unwrap_or_else(|| <super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation(&mut self) -> &mut super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        if self.reservation.is_none() {
            self.reservation.set_default();
        }
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        self.reservation.take().unwrap_or_else(|| super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new())
    }
}

impl ::protobuf::Message for CCSUsrMsg_ServerRankRevealAll {
    fn is_initialized(&self) -> bool {
        for v in &self.reservation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seconds_till_shutdown = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_till_shutdown {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seconds_till_shutdown {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.reservation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCSUsrMsg_ServerRankRevealAll {
        CCSUsrMsg_ServerRankRevealAll::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seconds_till_shutdown",
                |m: &CCSUsrMsg_ServerRankRevealAll| { &m.seconds_till_shutdown },
                |m: &mut CCSUsrMsg_ServerRankRevealAll| { &mut m.seconds_till_shutdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>>(
                "reservation",
                |m: &CCSUsrMsg_ServerRankRevealAll| { &m.reservation },
                |m: &mut CCSUsrMsg_ServerRankRevealAll| { &mut m.reservation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCSUsrMsg_ServerRankRevealAll>(
                "CCSUsrMsg_ServerRankRevealAll",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankRevealAll {
        static instance: ::protobuf::rt::LazyV2<CCSUsrMsg_ServerRankRevealAll> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCSUsrMsg_ServerRankRevealAll::new)
    }
}

impl ::protobuf::Clear for CCSUsrMsg_ServerRankRevealAll {
    fn clear(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
        self.reservation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCSUsrMsg_ServerRankRevealAll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ServerRankRevealAll {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ECstrike15UserMessages {
    CS_UM_VGUIMenu = 1,
    CS_UM_Geiger = 2,
    CS_UM_Train = 3,
    CS_UM_HudText = 4,
    CS_UM_SayText = 5,
    CS_UM_SayText2 = 6,
    CS_UM_TextMsg = 7,
    CS_UM_HudMsg = 8,
    CS_UM_ResetHud = 9,
    CS_UM_GameTitle = 10,
    CS_UM_Shake = 12,
    CS_UM_Fade = 13,
    CS_UM_Rumble = 14,
    CS_UM_CloseCaption = 15,
    CS_UM_CloseCaptionDirect = 16,
    CS_UM_SendAudio = 17,
    CS_UM_RawAudio = 18,
    CS_UM_VoiceMask = 19,
    CS_UM_RequestState = 20,
    CS_UM_Damage = 21,
    CS_UM_RadioText = 22,
    CS_UM_HintText = 23,
    CS_UM_KeyHintText = 24,
    CS_UM_ProcessSpottedEntityUpdate = 25,
    CS_UM_ReloadEffect = 26,
    CS_UM_AdjustMoney = 27,
    CS_UM_UpdateTeamMoney = 28,
    CS_UM_StopSpectatorMode = 29,
    CS_UM_KillCam = 30,
    CS_UM_DesiredTimescale = 31,
    CS_UM_CurrentTimescale = 32,
    CS_UM_AchievementEvent = 33,
    CS_UM_MatchEndConditions = 34,
    CS_UM_DisconnectToLobby = 35,
    CS_UM_PlayerStatsUpdate = 36,
    CS_UM_DisplayInventory = 37,
    CS_UM_WarmupHasEnded = 38,
    CS_UM_ClientInfo = 39,
    CS_UM_XRankGet = 40,
    CS_UM_XRankUpd = 41,
    CS_UM_CallVoteFailed = 45,
    CS_UM_VoteStart = 46,
    CS_UM_VotePass = 47,
    CS_UM_VoteFailed = 48,
    CS_UM_VoteSetup = 49,
    CS_UM_ServerRankRevealAll = 50,
    CS_UM_SendLastKillerDamageToClient = 51,
    CS_UM_ServerRankUpdate = 52,
    CS_UM_ItemPickup = 53,
    CS_UM_ShowMenu = 54,
    CS_UM_BarTime = 55,
    CS_UM_AmmoDenied = 56,
    CS_UM_MarkAchievement = 57,
    CS_UM_MatchStatsUpdate = 58,
    CS_UM_ItemDrop = 59,
    CS_UM_GlowPropTurnOff = 60,
    CS_UM_SendPlayerItemDrops = 61,
    CS_UM_RoundBackupFilenames = 62,
    CS_UM_SendPlayerItemFound = 63,
    CS_UM_ReportHit = 64,
    CS_UM_XpUpdate = 65,
    CS_UM_QuestProgress = 66,
    CS_UM_ScoreLeaderboardData = 67,
    CS_UM_PlayerDecalDigitalSignature = 68,
    CS_UM_WeaponSound = 69,
    CS_UM_UpdateScreenHealthBar = 70,
    CS_UM_EntityOutlineHighlight = 71,
    CS_UM_SSUI = 72,
    CS_UM_SurvivalStats = 73,
    CS_UM_DisconnectToLobby2 = 74,
    CS_UM_EndOfMatchAllPlayersData = 75,
    CS_UM_RoundImpactScoreData = 79,
    CS_UM_CurrentRoundOdds = 80,
    CS_UM_DeepStats = 81,
}

impl ::protobuf::ProtobufEnum for ECstrike15UserMessages {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECstrike15UserMessages> {
        match value {
            1 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VGUIMenu),
            2 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Geiger),
            3 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Train),
            4 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudText),
            5 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText),
            6 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText2),
            7 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_TextMsg),
            8 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudMsg),
            9 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ResetHud),
            10 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GameTitle),
            12 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Shake),
            13 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Fade),
            14 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Rumble),
            15 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaption),
            16 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaptionDirect),
            17 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendAudio),
            18 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RawAudio),
            19 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoiceMask),
            20 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RequestState),
            21 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Damage),
            22 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RadioText),
            23 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HintText),
            24 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KeyHintText),
            25 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate),
            26 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReloadEffect),
            27 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AdjustMoney),
            28 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateTeamMoney),
            29 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_StopSpectatorMode),
            30 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KillCam),
            31 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DesiredTimescale),
            32 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentTimescale),
            33 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AchievementEvent),
            34 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchEndConditions),
            35 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby),
            36 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerStatsUpdate),
            37 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisplayInventory),
            38 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WarmupHasEnded),
            39 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ClientInfo),
            40 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankGet),
            41 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankUpd),
            45 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CallVoteFailed),
            46 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteStart),
            47 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VotePass),
            48 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteFailed),
            49 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteSetup),
            50 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankRevealAll),
            51 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient),
            52 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankUpdate),
            53 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemPickup),
            54 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShowMenu),
            55 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_BarTime),
            56 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AmmoDenied),
            57 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MarkAchievement),
            58 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchStatsUpdate),
            59 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemDrop),
            60 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GlowPropTurnOff),
            61 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemDrops),
            62 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundBackupFilenames),
            63 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemFound),
            64 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReportHit),
            65 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XpUpdate),
            66 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_QuestProgress),
            67 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ScoreLeaderboardData),
            68 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature),
            69 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WeaponSound),
            70 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar),
            71 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EntityOutlineHighlight),
            72 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SSUI),
            73 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SurvivalStats),
            74 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby2),
            75 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData),
            79 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundImpactScoreData),
            80 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentRoundOdds),
            81 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DeepStats),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ECstrike15UserMessages] = &[
            ECstrike15UserMessages::CS_UM_VGUIMenu,
            ECstrike15UserMessages::CS_UM_Geiger,
            ECstrike15UserMessages::CS_UM_Train,
            ECstrike15UserMessages::CS_UM_HudText,
            ECstrike15UserMessages::CS_UM_SayText,
            ECstrike15UserMessages::CS_UM_SayText2,
            ECstrike15UserMessages::CS_UM_TextMsg,
            ECstrike15UserMessages::CS_UM_HudMsg,
            ECstrike15UserMessages::CS_UM_ResetHud,
            ECstrike15UserMessages::CS_UM_GameTitle,
            ECstrike15UserMessages::CS_UM_Shake,
            ECstrike15UserMessages::CS_UM_Fade,
            ECstrike15UserMessages::CS_UM_Rumble,
            ECstrike15UserMessages::CS_UM_CloseCaption,
            ECstrike15UserMessages::CS_UM_CloseCaptionDirect,
            ECstrike15UserMessages::CS_UM_SendAudio,
            ECstrike15UserMessages::CS_UM_RawAudio,
            ECstrike15UserMessages::CS_UM_VoiceMask,
            ECstrike15UserMessages::CS_UM_RequestState,
            ECstrike15UserMessages::CS_UM_Damage,
            ECstrike15UserMessages::CS_UM_RadioText,
            ECstrike15UserMessages::CS_UM_HintText,
            ECstrike15UserMessages::CS_UM_KeyHintText,
            ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate,
            ECstrike15UserMessages::CS_UM_ReloadEffect,
            ECstrike15UserMessages::CS_UM_AdjustMoney,
            ECstrike15UserMessages::CS_UM_UpdateTeamMoney,
            ECstrike15UserMessages::CS_UM_StopSpectatorMode,
            ECstrike15UserMessages::CS_UM_KillCam,
            ECstrike15UserMessages::CS_UM_DesiredTimescale,
            ECstrike15UserMessages::CS_UM_CurrentTimescale,
            ECstrike15UserMessages::CS_UM_AchievementEvent,
            ECstrike15UserMessages::CS_UM_MatchEndConditions,
            ECstrike15UserMessages::CS_UM_DisconnectToLobby,
            ECstrike15UserMessages::CS_UM_PlayerStatsUpdate,
            ECstrike15UserMessages::CS_UM_DisplayInventory,
            ECstrike15UserMessages::CS_UM_WarmupHasEnded,
            ECstrike15UserMessages::CS_UM_ClientInfo,
            ECstrike15UserMessages::CS_UM_XRankGet,
            ECstrike15UserMessages::CS_UM_XRankUpd,
            ECstrike15UserMessages::CS_UM_CallVoteFailed,
            ECstrike15UserMessages::CS_UM_VoteStart,
            ECstrike15UserMessages::CS_UM_VotePass,
            ECstrike15UserMessages::CS_UM_VoteFailed,
            ECstrike15UserMessages::CS_UM_VoteSetup,
            ECstrike15UserMessages::CS_UM_ServerRankRevealAll,
            ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient,
            ECstrike15UserMessages::CS_UM_ServerRankUpdate,
            ECstrike15UserMessages::CS_UM_ItemPickup,
            ECstrike15UserMessages::CS_UM_ShowMenu,
            ECstrike15UserMessages::CS_UM_BarTime,
            ECstrike15UserMessages::CS_UM_AmmoDenied,
            ECstrike15UserMessages::CS_UM_MarkAchievement,
            ECstrike15UserMessages::CS_UM_MatchStatsUpdate,
            ECstrike15UserMessages::CS_UM_ItemDrop,
            ECstrike15UserMessages::CS_UM_GlowPropTurnOff,
            ECstrike15UserMessages::CS_UM_SendPlayerItemDrops,
            ECstrike15UserMessages::CS_UM_RoundBackupFilenames,
            ECstrike15UserMessages::CS_UM_SendPlayerItemFound,
            ECstrike15UserMessages::CS_UM_ReportHit,
            ECstrike15UserMessages::CS_UM_XpUpdate,
            ECstrike15UserMessages::CS_UM_QuestProgress,
            ECstrike15UserMessages::CS_UM_ScoreLeaderboardData,
            ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature,
            ECstrike15UserMessages::CS_UM_WeaponSound,
            ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar,
            ECstrike15UserMessages::CS_UM_EntityOutlineHighlight,
            ECstrike15UserMessages::CS_UM_SSUI,
            ECstrike15UserMessages::CS_UM_SurvivalStats,
            ECstrike15UserMessages::CS_UM_DisconnectToLobby2,
            ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData,
            ECstrike15UserMessages::CS_UM_RoundImpactScoreData,
            ECstrike15UserMessages::CS_UM_CurrentRoundOdds,
            ECstrike15UserMessages::CS_UM_DeepStats,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ECstrike15UserMessages>("ECstrike15UserMessages", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ECstrike15UserMessages {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECstrike15UserMessages {
    fn default() -> Self {
        ECstrike15UserMessages::CS_UM_VGUIMenu
    }
}

impl ::protobuf::reflect::ProtobufValue for ECstrike15UserMessages {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ECSUsrMsg_DisconnectToLobby_Action {
    k_ECSUsrMsg_DisconnectToLobby_Action_Default = 0,
    k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue = 1,
}

impl ::protobuf::ProtobufEnum for ECSUsrMsg_DisconnectToLobby_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECSUsrMsg_DisconnectToLobby_Action> {
        match value {
            0 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default),
            1 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ECSUsrMsg_DisconnectToLobby_Action] = &[
            ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default,
            ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ECSUsrMsg_DisconnectToLobby_Action>("ECSUsrMsg_DisconnectToLobby_Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ECSUsrMsg_DisconnectToLobby_Action {
}

impl ::std::default::Default for ECSUsrMsg_DisconnectToLobby_Action {
    fn default() -> Self {
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default
    }
}

impl ::protobuf::reflect::ProtobufValue for ECSUsrMsg_DisconnectToLobby_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ccstrike15_usermessages.proto\x1a\x20google/protobuf/descriptor.pro\
    to\x1a\x11netmessages.proto\x1a\x1acstrike15_gcmessages.proto\"\xa2\x01\
    \n\x12CCSUsrMsg_VGUIMenu\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x12\n\x04show\x18\x02\x20\x01(\x08R\x04show\x124\n\x07subkeys\x18\
    \x03\x20\x03(\x0b2\x1a.CCSUsrMsg_VGUIMenu.SubkeyR\x07subkeys\x1a.\n\x06S\
    ubkey\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x10\n\x03str\x18\
    \x02\x20\x01(\tR\x03str\"(\n\x10CCSUsrMsg_Geiger\x12\x14\n\x05range\x18\
    \x01\x20\x01(\x05R\x05range\"'\n\x0fCCSUsrMsg_Train\x12\x14\n\x05train\
    \x18\x01\x20\x01(\x05R\x05train\"'\n\x11CCSUsrMsg_HudText\x12\x12\n\x04t\
    ext\x18\x01\x20\x01(\tR\x04text\"v\n\x11CCSUsrMsg_SayText\x12\x17\n\x07e\
    nt_idx\x18\x01\x20\x01(\x05R\x06entIdx\x12\x12\n\x04text\x18\x02\x20\x01\
    (\tR\x04text\x12\x12\n\x04chat\x18\x03\x20\x01(\x08R\x04chat\x12\x20\n\
    \x0btextallchat\x18\x04\x20\x01(\x08R\x0btextallchat\"\x96\x01\n\x12CCSU\
    srMsg_SayText2\x12\x17\n\x07ent_idx\x18\x01\x20\x01(\x05R\x06entIdx\x12\
    \x12\n\x04chat\x18\x02\x20\x01(\x08R\x04chat\x12\x19\n\x08msg_name\x18\
    \x03\x20\x01(\tR\x07msgName\x12\x16\n\x06params\x18\x04\x20\x03(\tR\x06p\
    arams\x12\x20\n\x0btextallchat\x18\x05\x20\x01(\x08R\x0btextallchat\"D\n\
    \x11CCSUsrMsg_TextMsg\x12\x17\n\x07msg_dst\x18\x01\x20\x01(\x05R\x06msgD\
    st\x12\x16\n\x06params\x18\x03\x20\x03(\tR\x06params\"\xb3\x02\n\x10CCSU\
    srMsg_HudMsg\x12\x18\n\x07channel\x18\x01\x20\x01(\x05R\x07channel\x12\
    \x1f\n\x03pos\x18\x02\x20\x01(\x0b2\r.CMsgVector2DR\x03pos\x12\x1d\n\x04\
    clr1\x18\x03\x20\x01(\x0b2\t.CMsgRGBAR\x04clr1\x12\x1d\n\x04clr2\x18\x04\
    \x20\x01(\x0b2\t.CMsgRGBAR\x04clr2\x12\x16\n\x06effect\x18\x05\x20\x01(\
    \x05R\x06effect\x12\x20\n\x0cfade_in_time\x18\x06\x20\x01(\x02R\nfadeInT\
    ime\x12\"\n\rfade_out_time\x18\x07\x20\x01(\x02R\x0bfadeOutTime\x12\x1b\
    \n\thold_time\x18\t\x20\x01(\x02R\x08holdTime\x12\x17\n\x07fx_time\x18\n\
    \x20\x01(\x02R\x06fxTime\x12\x12\n\x04text\x18\x0b\x20\x01(\tR\x04text\"\
    \x8e\x01\n\x0fCCSUsrMsg_Shake\x12\x18\n\x07command\x18\x01\x20\x01(\x05R\
    \x07command\x12'\n\x0flocal_amplitude\x18\x02\x20\x01(\x02R\x0elocalAmpl\
    itude\x12\x1c\n\tfrequency\x18\x03\x20\x01(\x02R\tfrequency\x12\x1a\n\
    \x08duration\x18\x04\x20\x01(\x02R\x08duration\"|\n\x0eCCSUsrMsg_Fade\
    \x12\x1a\n\x08duration\x18\x01\x20\x01(\x05R\x08duration\x12\x1b\n\thold\
    _time\x18\x02\x20\x01(\x05R\x08holdTime\x12\x14\n\x05flags\x18\x03\x20\
    \x01(\x05R\x05flags\x12\x1b\n\x03clr\x18\x04\x20\x01(\x0b2\t.CMsgRGBAR\
    \x03clr\"R\n\x10CCSUsrMsg_Rumble\x12\x14\n\x05index\x18\x01\x20\x01(\x05\
    R\x05index\x12\x12\n\x04data\x18\x02\x20\x01(\x05R\x04data\x12\x14\n\x05\
    flags\x18\x03\x20\x01(\x05R\x05flags\"\x83\x01\n\x16CCSUsrMsg_CloseCapti\
    on\x12\x12\n\x04hash\x18\x01\x20\x01(\rR\x04hash\x12\x1a\n\x08duration\
    \x18\x02\x20\x01(\x05R\x08duration\x12\x1f\n\x0bfrom_player\x18\x03\x20\
    \x01(\x08R\nfromPlayer\x12\x18\n\x07cctoken\x18\x04\x20\x01(\tR\x07cctok\
    en\"o\n\x1cCCSUsrMsg_CloseCaptionDirect\x12\x12\n\x04hash\x18\x01\x20\
    \x01(\rR\x04hash\x12\x1a\n\x08duration\x18\x02\x20\x01(\x05R\x08duration\
    \x12\x1f\n\x0bfrom_player\x18\x03\x20\x01(\x08R\nfromPlayer\"6\n\x13CCSU\
    srMsg_SendAudio\x12\x1f\n\x0bradio_sound\x18\x01\x20\x01(\tR\nradioSound\
    \"\x85\x01\n\x12CCSUsrMsg_RawAudio\x12\x14\n\x05pitch\x18\x01\x20\x01(\
    \x05R\x05pitch\x12\x16\n\x06entidx\x18\x02\x20\x01(\x05R\x06entidx\x12\
    \x1a\n\x08duration\x18\x03\x20\x01(\x02R\x08duration\x12%\n\x0evoice_fil\
    ename\x18\x04\x20\x01(\tR\rvoiceFilename\"\xd8\x01\n\x13CCSUsrMsg_VoiceM\
    ask\x12B\n\x0cplayer_masks\x18\x01\x20\x03(\x0b2\x1f.CCSUsrMsg_VoiceMask\
    .PlayerMaskR\x0bplayerMasks\x12*\n\x11player_mod_enable\x18\x02\x20\x01(\
    \x08R\x0fplayerModEnable\x1aQ\n\nPlayerMask\x12&\n\x0fgame_rules_mask\
    \x18\x01\x20\x01(\x05R\rgameRulesMask\x12\x1b\n\tban_masks\x18\x02\x20\
    \x01(\x05R\x08banMasks\"\x90\x01\n\x10CCSUsrMsg_Damage\x12\x16\n\x06amou\
    nt\x18\x01\x20\x01(\x05R\x06amount\x12;\n\x13inflictor_world_pos\x18\x02\
    \x20\x01(\x0b2\x0b.CMsgVectorR\x11inflictorWorldPos\x12'\n\x0fvictim_ent\
    index\x18\x03\x20\x01(\x05R\x0evictimEntindex\"y\n\x13CCSUsrMsg_RadioTex\
    t\x12\x17\n\x07msg_dst\x18\x01\x20\x01(\x05R\x06msgDst\x12\x16\n\x06clie\
    nt\x18\x02\x20\x01(\x05R\x06client\x12\x19\n\x08msg_name\x18\x03\x20\x01\
    (\tR\x07msgName\x12\x16\n\x06params\x18\x04\x20\x03(\tR\x06params\"(\n\
    \x12CCSUsrMsg_HintText\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"-\
    \n\x15CCSUsrMsg_KeyHintText\x12\x14\n\x05hints\x18\x01\x20\x03(\tR\x05hi\
    nts\"\xcf\x03\n$CCSUsrMsg_ProcessSpottedEntityUpdate\x12\x1d\n\nnew_upda\
    te\x18\x01\x20\x01(\x08R\tnewUpdate\x12`\n\x0eentity_updates\x18\x02\x20\
    \x03(\x0b29.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdateR\re\
    ntityUpdates\x1a\xa5\x02\n\x13SpottedEntityUpdate\x12\x1d\n\nentity_idx\
    \x18\x01\x20\x01(\x05R\tentityIdx\x12\x19\n\x08class_id\x18\x02\x20\x01(\
    \x05R\x07classId\x12\x19\n\x08origin_x\x18\x03\x20\x01(\x05R\x07originX\
    \x12\x19\n\x08origin_y\x18\x04\x20\x01(\x05R\x07originY\x12\x19\n\x08ori\
    gin_z\x18\x05\x20\x01(\x05R\x07originZ\x12\x17\n\x07angle_y\x18\x06\x20\
    \x01(\x05R\x06angleY\x12\x18\n\x07defuser\x18\x07\x20\x01(\x08R\x07defus\
    er\x12,\n\x12player_has_defuser\x18\x08\x20\x01(\x08R\x10playerHasDefuse\
    r\x12\"\n\rplayer_has_c4\x18\t\x20\x01(\x08R\x0bplayerHasC4\"b\n\x1dCCSU\
    srMsg_SendPlayerItemDrops\x12A\n\x0eentity_updates\x18\x01\x20\x03(\x0b2\
    \x1a.CEconItemPreviewDataBlockR\rentityUpdates\"s\n\x1dCCSUsrMsg_SendPla\
    yerItemFound\x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CEconItemPrevi\
    ewDataBlockR\x08iteminfo\x12\x1a\n\x08entindex\x18\x02\x20\x01(\x05R\x08\
    entindex\"\x9b\x01\n\x16CCSUsrMsg_ReloadEffect\x12\x16\n\x06entidx\x18\
    \x01\x20\x01(\x05R\x06entidx\x12\x18\n\x07actanim\x18\x02\x20\x01(\x05R\
    \x07actanim\x12\x19\n\x08origin_x\x18\x03\x20\x01(\x02R\x07originX\x12\
    \x19\n\x08origin_y\x18\x04\x20\x01(\x02R\x07originY\x12\x19\n\x08origin_\
    z\x18\x05\x20\x01(\x02R\x07originZ\"\xb4\x01\n\x15CCSUsrMsg_WeaponSound\
    \x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\x12\x19\n\x08origin\
    _x\x18\x02\x20\x01(\x02R\x07originX\x12\x19\n\x08origin_y\x18\x03\x20\
    \x01(\x02R\x07originY\x12\x19\n\x08origin_z\x18\x04\x20\x01(\x02R\x07ori\
    ginZ\x12\x14\n\x05sound\x18\x05\x20\x01(\tR\x05sound\x12\x1c\n\ttimestam\
    p\x18\x06\x20\x01(\x02R\ttimestamp\"\xa1\x01\n\x1fCCSUsrMsg_UpdateScreen\
    HealthBar\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\x12'\n\x0f\
    healthratio_old\x18\x02\x20\x01(\x02R\x0ehealthratioOld\x12'\n\x0fhealth\
    ratio_new\x18\x03\x20\x01(\x02R\x0ehealthratioNew\x12\x14\n\x05style\x18\
    \x04\x20\x01(\x05R\x05style\"d\n\x20CCSUsrMsg_EntityOutlineHighlight\x12\
    \x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\x12(\n\x0fremovehighlig\
    ht\x18\x02\x20\x01(\x08R\x0fremovehighlight\"/\n\x15CCSUsrMsg_AdjustMone\
    y\x12\x16\n\x06amount\x18\x01\x20\x01(\x05R\x06amount\"r\n\x13CCSUsrMsg_\
    ReportHit\x12\x13\n\x05pos_x\x18\x01\x20\x01(\x02R\x04posX\x12\x13\n\x05\
    pos_y\x18\x02\x20\x01(\x02R\x04posY\x12\x1c\n\ttimestamp\x18\x04\x20\x01\
    (\x02R\ttimestamp\x12\x13\n\x05pos_z\x18\x03\x20\x01(\x02R\x04posZ\"v\n\
    \x11CCSUsrMsg_KillCam\x12\x19\n\x08obs_mode\x18\x01\x20\x01(\x05R\x07obs\
    Mode\x12!\n\x0cfirst_target\x18\x02\x20\x01(\x05R\x0bfirstTarget\x12#\n\
    \rsecond_target\x18\x03\x20\x01(\x05R\x0csecondTarget\"\xd4\x01\n\x1aCCS\
    UsrMsg_DesiredTimescale\x12+\n\x11desired_timescale\x18\x01\x20\x01(\x02\
    R\x10desiredTimescale\x122\n\x15duration_realtime_sec\x18\x02\x20\x01(\
    \x02R\x13durationRealtimeSec\x12+\n\x11interpolator_type\x18\x03\x20\x01\
    (\x05R\x10interpolatorType\x12(\n\x10start_blend_time\x18\x04\x20\x01(\
    \x02R\x0estartBlendTime\"A\n\x1aCCSUsrMsg_CurrentTimescale\x12#\n\rcur_t\
    imescale\x18\x01\x20\x01(\x02R\x0ccurTimescale\"m\n\x1aCCSUsrMsg_Achieve\
    mentEvent\x12\x20\n\x0bachievement\x18\x01\x20\x01(\x05R\x0bachievement\
    \x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\x12\x17\n\x07user_id\
    \x18\x03\x20\x01(\x05R\x06userId\"\xa3\x01\n\x1cCCSUsrMsg_MatchEndCondit\
    ions\x12\x1c\n\tfraglimit\x18\x01\x20\x01(\x05R\tfraglimit\x12!\n\x0cmp_\
    maxrounds\x18\x02\x20\x01(\x05R\x0bmpMaxrounds\x12\x1f\n\x0bmp_winlimit\
    \x18\x03\x20\x01(\x05R\nmpWinlimit\x12!\n\x0cmp_timelimit\x18\x04\x20\
    \x01(\x05R\x0bmpTimelimit\"\xcb\x01\n\x1bCCSUsrMsg_PlayerStatsUpdate\x12\
    \x18\n\x07version\x18\x01\x20\x01(\x05R\x07version\x127\n\x05stats\x18\
    \x04\x20\x03(\x0b2!.CCSUsrMsg_PlayerStatsUpdate.StatR\x05stats\x12\x17\n\
    \x07user_id\x18\x05\x20\x01(\x05R\x06userId\x12\x10\n\x03crc\x18\x06\x20\
    \x01(\x05R\x03crc\x1a.\n\x04Stat\x12\x10\n\x03idx\x18\x01\x20\x01(\x05R\
    \x03idx\x12\x14\n\x05delta\x18\x02\x20\x01(\x05R\x05delta\"O\n\x1aCCSUsr\
    Msg_DisplayInventory\x12\x18\n\x07display\x18\x01\x20\x01(\x08R\x07displ\
    ay\x12\x17\n\x07user_id\x18\x02\x20\x01(\x05R\x06userId\"\xa2\x01\n\x17C\
    CSUsrMsg_QuestProgress\x12\x19\n\x08quest_id\x18\x01\x20\x01(\rR\x07ques\
    tId\x12#\n\rnormal_points\x18\x02\x20\x01(\rR\x0cnormalPoints\x12!\n\x0c\
    bonus_points\x18\x03\x20\x01(\rR\x0bbonusPoints\x12$\n\x0eis_event_quest\
    \x18\x04\x20\x01(\x08R\x0cisEventQuest\"K\n\x1eCCSUsrMsg_ScoreLeaderboar\
    dData\x12)\n\x04data\x18\x01\x20\x01(\x0b2\x15.ScoreLeaderboardDataR\x04\
    data\"Y\n%CCSUsrMsg_PlayerDecalDigitalSignature\x120\n\x04data\x18\x01\
    \x20\x01(\x0b2\x1c.PlayerDecalDigitalSignatureR\x04data\"O\n\x12CCSUsrMs\
    g_XRankGet\x12\x19\n\x08mode_idx\x18\x01\x20\x01(\x05R\x07modeIdx\x12\
    \x1e\n\ncontroller\x18\x02\x20\x01(\x05R\ncontroller\"i\n\x12CCSUsrMsg_X\
    RankUpd\x12\x19\n\x08mode_idx\x18\x01\x20\x01(\x05R\x07modeIdx\x12\x1e\n\
    \ncontroller\x18\x02\x20\x01(\x05R\ncontroller\x12\x18\n\x07ranking\x18\
    \x03\x20\x01(\x05R\x07ranking\"F\n\x18CCSUsrMsg_CallVoteFailed\x12\x16\n\
    \x06reason\x18\x01\x20\x01(\x05R\x06reason\x12\x12\n\x04time\x18\x02\x20\
    \x01(\x05R\x04time\"\x8b\x02\n\x13CCSUsrMsg_VoteStart\x12\x12\n\x04team\
    \x18\x01\x20\x01(\x05R\x04team\x12\x17\n\x07ent_idx\x18\x02\x20\x01(\x05\
    R\x06entIdx\x12\x1b\n\tvote_type\x18\x03\x20\x01(\x05R\x08voteType\x12\
    \x19\n\x08disp_str\x18\x04\x20\x01(\tR\x07dispStr\x12\x1f\n\x0bdetails_s\
    tr\x18\x05\x20\x01(\tR\ndetailsStr\x12$\n\x0eother_team_str\x18\x06\x20\
    \x01(\tR\x0cotherTeamStr\x12#\n\x0eis_yes_no_vote\x18\x07\x20\x01(\x08R\
    \x0bisYesNoVote\x12#\n\rentidx_target\x18\x08\x20\x01(\x05R\x0centidxTar\
    get\"\x81\x01\n\x12CCSUsrMsg_VotePass\x12\x12\n\x04team\x18\x01\x20\x01(\
    \x05R\x04team\x12\x1b\n\tvote_type\x18\x02\x20\x01(\x05R\x08voteType\x12\
    \x19\n\x08disp_str\x18\x03\x20\x01(\tR\x07dispStr\x12\x1f\n\x0bdetails_s\
    tr\x18\x04\x20\x01(\tR\ndetailsStr\"B\n\x14CCSUsrMsg_VoteFailed\x12\x12\
    \n\x04team\x18\x01\x20\x01(\x05R\x04team\x12\x16\n\x06reason\x18\x02\x20\
    \x01(\x05R\x06reason\"@\n\x13CCSUsrMsg_VoteSetup\x12)\n\x10potential_iss\
    ues\x18\x01\x20\x03(\tR\x0fpotentialIssues\"\xba\x01\n&CCSUsrMsg_SendLas\
    tKillerDamageToClient\x12$\n\x0enum_hits_given\x18\x01\x20\x01(\x05R\x0c\
    numHitsGiven\x12!\n\x0cdamage_given\x18\x02\x20\x01(\x05R\x0bdamageGiven\
    \x12$\n\x0enum_hits_taken\x18\x03\x20\x01(\x05R\x0cnumHitsTaken\x12!\n\
    \x0cdamage_taken\x18\x04\x20\x01(\x05R\x0bdamageTaken\"\xa7\x02\n\x1aCCS\
    UsrMsg_ServerRankUpdate\x12G\n\x0brank_update\x18\x01\x20\x03(\x0b2&.CCS\
    UsrMsg_ServerRankUpdate.RankUpdateR\nrankUpdate\x1a\xbf\x01\n\nRankUpdat\
    e\x12\x1d\n\naccount_id\x18\x01\x20\x01(\x05R\taccountId\x12\x19\n\x08ra\
    nk_old\x18\x02\x20\x01(\x05R\x07rankOld\x12\x19\n\x08rank_new\x18\x03\
    \x20\x01(\x05R\x07rankNew\x12\x19\n\x08num_wins\x18\x04\x20\x01(\x05R\
    \x07numWins\x12\x1f\n\x0brank_change\x18\x05\x20\x01(\x02R\nrankChange\
    \x12\x20\n\x0crank_type_id\x18\x06\x20\x01(\x05R\nrankTypeId\"W\n\x12CCS\
    UsrMsg_XpUpdate\x12A\n\x04data\x18\x01\x20\x01(\x0b2-.CMsgGCCstrike15_v2\
    _GC2ServerNotifyXPRewardedR\x04data\"*\n\x14CCSUsrMsg_ItemPickup\x12\x12\
    \n\x04item\x18\x01\x20\x01(\tR\x04item\"\x82\x01\n\x12CCSUsrMsg_ShowMenu\
    \x12(\n\x10bits_valid_slots\x18\x01\x20\x01(\x05R\x0ebitsValidSlots\x12!\
    \n\x0cdisplay_time\x18\x02\x20\x01(\x05R\x0bdisplayTime\x12\x1f\n\x0bmen\
    u_string\x18\x03\x20\x01(\tR\nmenuString\"'\n\x11CCSUsrMsg_BarTime\x12\
    \x12\n\x04time\x18\x01\x20\x01(\tR\x04time\"0\n\x14CCSUsrMsg_AmmoDenied\
    \x12\x18\n\x07ammoIdx\x18\x01\x20\x01(\x05R\x07ammoIdx\"=\n\x19CCSUsrMsg\
    _MarkAchievement\x12\x20\n\x0bachievement\x18\x01\x20\x01(\tR\x0bachieve\
    ment\"4\n\x1aCCSUsrMsg_MatchStatsUpdate\x12\x16\n\x06update\x18\x01\x20\
    \x01(\tR\x06update\"B\n\x12CCSUsrMsg_ItemDrop\x12\x16\n\x06itemid\x18\
    \x01\x20\x01(\x03R\x06itemid\x12\x14\n\x05death\x18\x02\x20\x01(\x08R\
    \x05death\"3\n\x19CCSUsrMsg_GlowPropTurnOff\x12\x16\n\x06entidx\x18\x01\
    \x20\x01(\x05R\x06entidx\"\x84\x01\n\x1eCCSUsrMsg_RoundBackupFilenames\
    \x12\x14\n\x05count\x18\x01\x20\x01(\x05R\x05count\x12\x14\n\x05index\
    \x18\x02\x20\x01(\x05R\x05index\x12\x1a\n\x08filename\x18\x03\x20\x01(\t\
    R\x08filename\x12\x1a\n\x08nicename\x18\x04\x20\x01(\tR\x08nicename\"^\n\
    \x0eCCSUsrMsg_SSUI\x12\x12\n\x04show\x18\x01\x20\x01(\x08R\x04show\x12\
    \x1d\n\nstart_time\x18\x02\x20\x01(\x02R\tstartTime\x12\x19\n\x08end_tim\
    e\x18\x03\x20\x01(\x02R\x07endTime\"\xc4\x04\n\x17CCSUsrMsg_SurvivalStat\
    s\x12\x12\n\x04xuid\x18\x01\x20\x01(\x04R\x04xuid\x123\n\x05facts\x18\
    \x02\x20\x03(\x0b2\x1d.CCSUsrMsg_SurvivalStats.FactR\x05facts\x128\n\x05\
    users\x18\x03\x20\x03(\x0b2\".CCSUsrMsg_SurvivalStats.PlacementR\x05user\
    s\x129\n\x07damages\x18\x05\x20\x03(\x0b2\x1f.CCSUsrMsg_SurvivalStats.Da\
    mageR\x07damages\x12\x1e\n\nticknumber\x18\x04\x20\x01(\x05R\nticknumber\
    \x1at\n\x04Fact\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\x18\
    \n\x07display\x18\x02\x20\x01(\x05R\x07display\x12\x14\n\x05value\x18\
    \x03\x20\x01(\x05R\x05value\x12(\n\x0finterestingness\x18\x04\x20\x01(\
    \x02R\x0finterestingness\x1a]\n\tPlacement\x12\x12\n\x04xuid\x18\x01\x20\
    \x01(\x04R\x04xuid\x12\x1e\n\nteamnumber\x18\x02\x20\x01(\x05R\nteamnumb\
    er\x12\x1c\n\tplacement\x18\x03\x20\x01(\x05R\tplacement\x1av\n\x06Damag\
    e\x12\x12\n\x04xuid\x18\x01\x20\x01(\x04R\x04xuid\x12\x0e\n\x02to\x18\
    \x02\x20\x01(\x05R\x02to\x12\x17\n\x07to_hits\x18\x03\x20\x01(\x05R\x06t\
    oHits\x12\x12\n\x04from\x18\x04\x20\x01(\x05R\x04from\x12\x1b\n\tfrom_hi\
    ts\x18\x05\x20\x01(\x05R\x08fromHits\"\x97\x04\n\"CCSUsrMsg_EndOfMatchAl\
    lPlayersData\x12T\n\rallplayerdata\x18\x01\x20\x03(\x0b2..CCSUsrMsg_EndO\
    fMatchAllPlayersData.PlayerDataR\rallplayerdata\x12\x14\n\x05scene\x18\
    \x02\x20\x01(\x05R\x05scene\x1aZ\n\x08Accolade\x12\x1c\n\teaccolade\x18\
    \x01\x20\x01(\x05R\teaccolade\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\
    \x05value\x12\x1a\n\x08position\x18\x03\x20\x01(\x05R\x08position\x1a\
    \xa8\x02\n\nPlayerData\x12\x1a\n\x08entindex\x18\x01\x20\x01(\x05R\x08en\
    tindex\x12\x12\n\x04xuid\x18\x02\x20\x01(\x04R\x04xuid\x12\x12\n\x04name\
    \x18\x03\x20\x01(\tR\x04name\x12\x1e\n\nteamnumber\x18\x04\x20\x01(\x05R\
    \nteamnumber\x12L\n\nnomination\x18\x05\x20\x01(\x0b2,.CCSUsrMsg_EndOfMa\
    tchAllPlayersData.AccoladeR\nnomination\x120\n\x05items\x18\x06\x20\x03(\
    \x0b2\x1a.CEconItemPreviewDataBlockR\x05items\x12\x20\n\x0bplayercolor\
    \x18\x07\x20\x01(\x05R\x0bplayercolor\x12\x14\n\x05isbot\x18\x08\x20\x01\
    (\x08R\x05isbot\"\x9c\t\n\x1eCCSUsrMsg_RoundImpactScoreData\x12Z\n\x0fin\
    it_conditions\x18\x01\x20\x01(\x0b21.CCSUsrMsg_RoundImpactScoreData.Init\
    ialConditionsR\x0einitConditions\x12U\n\x12all_ris_event_data\x18\x02\
    \x20\x03(\x0b2(.CCSUsrMsg_RoundImpactScoreData.RisEventR\x0fallRisEventD\
    ata\x1a\xbf\x06\n\x08RisEvent\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x02R\
    \ttimestamp\x12%\n\x0eterrorist_odds\x18\x02\x20\x01(\x05R\rterroristOdd\
    s\x12\x19\n\x08ct_alive\x18\x03\x20\x01(\x05R\x07ctAlive\x12\x17\n\x07t_\
    alive\x18\x04\x20\x01(\x05R\x06tAlive\x12P\n\x0bvictim_data\x18\x05\x20\
    \x01(\x0b2/.CCSUsrMsg_RoundImpactScoreData.RisEvent.VictimR\nvictimData\
    \x12Y\n\x0eobjective_data\x18\x06\x20\x01(\x0b22.CCSUsrMsg_RoundImpactSc\
    oreData.RisEvent.ObjectiveR\robjectiveData\x12W\n\x0fall_damage_data\x18\
    \x07\x20\x03(\x0b2/.CCSUsrMsg_RoundImpactScoreData.RisEvent.DamageR\rall\
    DamageData\x1a\x9f\x01\n\x06Victim\x12\x1f\n\x0bteam_number\x18\x01\x20\
    \x01(\x05R\nteamNumber\x12\x1a\n\x08entindex\x18\x02\x20\x01(\x05R\x08en\
    tindex\x12\x12\n\x04xuid\x18\x03\x20\x01(\x04R\x04xuid\x12\x14\n\x05colo\
    r\x18\x04\x20\x01(\x05R\x05color\x12\x15\n\x06is_bot\x18\x05\x20\x01(\
    \x08R\x05isBot\x12\x17\n\x07is_dead\x18\x06\x20\x01(\x08R\x06isDead\x1a\
    \x1f\n\tObjective\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x1a\
    \xf0\x01\n\x06Damage\x12'\n\x0ftarget_entindex\x18\x01\x20\x01(\x05R\x0e\
    targetEntindex\x12\x1f\n\x0btarget_xuid\x18\x02\x20\x01(\x04R\ntargetXui\
    d\x12%\n\x0ehealth_removed\x18\x03\x20\x01(\x05R\rhealthRemoved\x12\x19\
    \n\x08num_hits\x18\x04\x20\x01(\x05R\x07numHits\x122\n\x15return_health_\
    removed\x18\x05\x20\x01(\x05R\x13returnHealthRemoved\x12&\n\x0fnum_retur\
    n_hits\x18\x06\x20\x01(\x05R\rnumReturnHits\x1a\x84\x01\n\x11InitialCond\
    itions\x12$\n\x0ect_equip_value\x18\x01\x20\x01(\x05R\x0cctEquipValue\
    \x12\"\n\rt_equip_value\x18\x02\x20\x01(\x05R\x0btEquipValue\x12%\n\x0et\
    errorist_odds\x18\x03\x20\x01(\x05R\rterroristOdds\"0\n\x1aCCSUsrMsg_Cur\
    rentRoundOdds\x12\x12\n\x04odds\x18\x01\x20\x01(\x05R\x04odds\"M\n\x13CC\
    SUsrMsg_DeepStats\x126\n\x05stats\x18\x01\x20\x01(\x0b2\x20.CMsgGCCStrik\
    e15_ClientDeepStatsR\x05stats\"*\n\x12CCSUsrMsg_ResetHud\x12\x14\n\x05re\
    set\x18\x01\x20\x01(\x08R\x05reset\"+\n\x13CCSUsrMsg_GameTitle\x12\x14\n\
    \x05dummy\x18\x01\x20\x01(\x05R\x05dummy\".\n\x16CCSUsrMsg_RequestState\
    \x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\"3\n\x1bCCSUsrMsg_Sto\
    pSpectatorMode\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\"3\n\
    \x1bCCSUsrMsg_DisconnectToLobby\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\
    \x05dummy\"0\n\x18CCSUsrMsg_WarmupHasEnded\x12\x14\n\x05dummy\x18\x01\
    \x20\x01(\x05R\x05dummy\",\n\x14CCSUsrMsg_ClientInfo\x12\x14\n\x05dummy\
    \x18\x01\x20\x01(\x05R\x05dummy\"\xa6\x01\n\x1dCCSUsrMsg_ServerRankRevea\
    lAll\x122\n\x15seconds_till_shutdown\x18\x01\x20\x01(\x05R\x13secondsTil\
    lShutdown\x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v\
    2_MatchmakingGC2ServerReserveR\x0breservation*\xaf\x0e\n\x16ECstrike15Us\
    erMessages\x12\x12\n\x0eCS_UM_VGUIMenu\x10\x01\x12\x10\n\x0cCS_UM_Geiger\
    \x10\x02\x12\x0f\n\x0bCS_UM_Train\x10\x03\x12\x11\n\rCS_UM_HudText\x10\
    \x04\x12\x11\n\rCS_UM_SayText\x10\x05\x12\x12\n\x0eCS_UM_SayText2\x10\
    \x06\x12\x11\n\rCS_UM_TextMsg\x10\x07\x12\x10\n\x0cCS_UM_HudMsg\x10\x08\
    \x12\x12\n\x0eCS_UM_ResetHud\x10\t\x12\x13\n\x0fCS_UM_GameTitle\x10\n\
    \x12\x0f\n\x0bCS_UM_Shake\x10\x0c\x12\x0e\n\nCS_UM_Fade\x10\r\x12\x10\n\
    \x0cCS_UM_Rumble\x10\x0e\x12\x16\n\x12CS_UM_CloseCaption\x10\x0f\x12\x1c\
    \n\x18CS_UM_CloseCaptionDirect\x10\x10\x12\x13\n\x0fCS_UM_SendAudio\x10\
    \x11\x12\x12\n\x0eCS_UM_RawAudio\x10\x12\x12\x13\n\x0fCS_UM_VoiceMask\
    \x10\x13\x12\x16\n\x12CS_UM_RequestState\x10\x14\x12\x10\n\x0cCS_UM_Dama\
    ge\x10\x15\x12\x13\n\x0fCS_UM_RadioText\x10\x16\x12\x12\n\x0eCS_UM_HintT\
    ext\x10\x17\x12\x15\n\x11CS_UM_KeyHintText\x10\x18\x12$\n\x20CS_UM_Proce\
    ssSpottedEntityUpdate\x10\x19\x12\x16\n\x12CS_UM_ReloadEffect\x10\x1a\
    \x12\x15\n\x11CS_UM_AdjustMoney\x10\x1b\x12\x19\n\x15CS_UM_UpdateTeamMon\
    ey\x10\x1c\x12\x1b\n\x17CS_UM_StopSpectatorMode\x10\x1d\x12\x11\n\rCS_UM\
    _KillCam\x10\x1e\x12\x1a\n\x16CS_UM_DesiredTimescale\x10\x1f\x12\x1a\n\
    \x16CS_UM_CurrentTimescale\x10\x20\x12\x1a\n\x16CS_UM_AchievementEvent\
    \x10!\x12\x1c\n\x18CS_UM_MatchEndConditions\x10\"\x12\x1b\n\x17CS_UM_Dis\
    connectToLobby\x10#\x12\x1b\n\x17CS_UM_PlayerStatsUpdate\x10$\x12\x1a\n\
    \x16CS_UM_DisplayInventory\x10%\x12\x18\n\x14CS_UM_WarmupHasEnded\x10&\
    \x12\x14\n\x10CS_UM_ClientInfo\x10'\x12\x12\n\x0eCS_UM_XRankGet\x10(\x12\
    \x12\n\x0eCS_UM_XRankUpd\x10)\x12\x18\n\x14CS_UM_CallVoteFailed\x10-\x12\
    \x13\n\x0fCS_UM_VoteStart\x10.\x12\x12\n\x0eCS_UM_VotePass\x10/\x12\x14\
    \n\x10CS_UM_VoteFailed\x100\x12\x13\n\x0fCS_UM_VoteSetup\x101\x12\x1d\n\
    \x19CS_UM_ServerRankRevealAll\x102\x12&\n\"CS_UM_SendLastKillerDamageToC\
    lient\x103\x12\x1a\n\x16CS_UM_ServerRankUpdate\x104\x12\x14\n\x10CS_UM_I\
    temPickup\x105\x12\x12\n\x0eCS_UM_ShowMenu\x106\x12\x11\n\rCS_UM_BarTime\
    \x107\x12\x14\n\x10CS_UM_AmmoDenied\x108\x12\x19\n\x15CS_UM_MarkAchievem\
    ent\x109\x12\x1a\n\x16CS_UM_MatchStatsUpdate\x10:\x12\x12\n\x0eCS_UM_Ite\
    mDrop\x10;\x12\x19\n\x15CS_UM_GlowPropTurnOff\x10<\x12\x1d\n\x19CS_UM_Se\
    ndPlayerItemDrops\x10=\x12\x1e\n\x1aCS_UM_RoundBackupFilenames\x10>\x12\
    \x1d\n\x19CS_UM_SendPlayerItemFound\x10?\x12\x13\n\x0fCS_UM_ReportHit\
    \x10@\x12\x12\n\x0eCS_UM_XpUpdate\x10A\x12\x17\n\x13CS_UM_QuestProgress\
    \x10B\x12\x1e\n\x1aCS_UM_ScoreLeaderboardData\x10C\x12%\n!CS_UM_PlayerDe\
    calDigitalSignature\x10D\x12\x15\n\x11CS_UM_WeaponSound\x10E\x12\x1f\n\
    \x1bCS_UM_UpdateScreenHealthBar\x10F\x12\x20\n\x1cCS_UM_EntityOutlineHig\
    hlight\x10G\x12\x0e\n\nCS_UM_SSUI\x10H\x12\x17\n\x13CS_UM_SurvivalStats\
    \x10I\x12\x1c\n\x18CS_UM_DisconnectToLobby2\x10J\x12\"\n\x1eCS_UM_EndOfM\
    atchAllPlayersData\x10K\x12\x1e\n\x1aCS_UM_RoundImpactScoreData\x10O\x12\
    \x1a\n\x16CS_UM_CurrentRoundOdds\x10P\x12\x13\n\x0fCS_UM_DeepStats\x10Q*\
    \x88\x01\n\"ECSUsrMsg_DisconnectToLobby_Action\x120\n,k_ECSUsrMsg_Discon\
    nectToLobby_Action_Default\x10\0\x120\n,k_ECSUsrMsg_DisconnectToLobby_Ac\
    tion_GoQueue\x10\x01B\x05H\x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
